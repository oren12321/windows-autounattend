<?xml version="1.0" encoding="utf-8"?>
<unattend xmlns="urn:schemas-microsoft-com:unattend" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State">
	<!--https://schneegans.de/windows/unattend-generator/?LanguageMode=Interactive&ProcessorArchitecture=amd64&BypassRequirementsCheck=true&BypassNetworkCheck=true&KeepSensitiveFiles=true&ComputerNameMode=Random&CompactOsMode=Never&TimeZoneMode=Implicit&PartitionMode=Interactive&DiskAssertionMode=Skip&WindowsEditionMode=Interactive&InstallFromMode=Automatic&PEMode=Default&UserAccountMode=InteractiveLocal&PasswordExpirationMode=Unlimited&LockoutMode=Default&HideFiles=None&ShowFileExtensions=true&ClassicContextMenu=true&LaunchToThisPC=true&ShowEndTask=true&TaskbarSearch=Hide&TaskbarIconsMode=Default&DisableWidgets=true&LeftTaskbar=true&HideTaskViewButton=true&DisableBingResults=true&StartTilesMode=Empty&StartPinsMode=Empty&DisableWindowsUpdate=true&DisableSac=true&DisableFastStartup=true&DisableSystemRestore=true&EnableLongPaths=true&AllowPowerShellScripts=true&DisableLastAccess=true&PreventAutomaticReboot=true&TurnOffSystemSounds=true&DisableAppSuggestions=true&PreventDeviceEncryption=true&HideEdgeFre=true&DisableEdgeStartupBoost=true&DisablePointerPrecision=true&DisableAutomaticRestartSignOn=true&EffectsMode=Custom&ThumbnailsOrIcon=true&DragFullWindows=true&FontSmoothing=true&DeleteEdgeDesktopIcon=true&DesktopIconsMode=Default&StartFoldersMode=Default&WifiMode=Skip&ExpressSettings=DisableAll&LockKeysMode=Skip&StickyKeysMode=Default&ColorMode=Default&WallpaperMode=Default&LockScreenMode=Default&Remove3DViewer=true&RemoveBingSearch=true&RemoveClipchamp=true&RemoveCopilot=true&RemoveCortana=true&RemoveDevHome=true&RemoveWindowsHello=true&RemoveFamily=true&RemoveFeedbackHub=true&RemoveGameAssist=true&RemoveGetHelp=true&RemoveHandwriting=true&RemoveMailCalendar=true&RemoveMaps=true&RemoveMathInputPanel=true&RemoveMixedReality=true&RemoveZuneVideo=true&RemoveNews=true&RemoveOffice365=true&RemoveOneDrive=true&RemoveOneNote=true&RemoveOneSync=true&RemoveOutlook=true&RemovePaint3D=true&RemovePeople=true&RemovePowerAutomate=true&RemovePowerShellISE=true&RemoveQuickAssist=true&RemoveRecall=true&RemoveRdpClient=true&RemoveSkype=true&RemoveSolitaire=true&RemoveSpeech=true&RemoveStepsRecorder=true&RemoveStickyNotes=true&RemoveTeams=true&RemoveGetStarted=true&RemoveToDo=true&RemoveWallet=true&RemoveWeather=true&RemoveFaxAndScan=true&RemoveWindowsMediaPlayer=true&RemoveWordPad=true&RemoveXboxApps=true&RemoveYourPhone=true&SystemScript0=%3C%21%5BCDATA%5B%3C%23%0D%0A%23+These+script+will+run+in+the+system+context%2C+before+user+accounts+are+created.%0D%0A%5D%5D%3E&SystemScriptType0=Ps1&DefaultUserScript0=%3C%21%5BCDATA%5B%3C%23%0D%0A%23+Use+this+script+to+modify+the+default+user%27s+registry+hive.+For+example%3A%0D%0A%23+Registry%3A%3AHKU%5CDefaultUser%5C...%0D%0A%5D%5D%3E&DefaultUserScriptType0=Ps1&FirstLogonScript0=%3C%21%5BCDATA%5B%3C%23%0D%0A%23+These+script+will+run+when+the+firt+user+logs+on+after+Windows+has+been+installed.%0D%0A%23+The+first+user+to+log+on+is+typically+an+administrator.%0D%0A%5D%5D%3E&FirstLogonScriptType0=Ps1&UserOnceScript0=%3C%21%5BCDATA%5B%3C%23%0D%0A%23+These+script+will+run+whenever+a+user+logs+on+for+the+first+time.%0D%0A%5D%5D%3E&UserOnceScriptType0=Ps1&WdacMode=Skip&AppLockerMode=Skip-->
	<settings pass="offlineServicing"></settings>
	<settings pass="windowsPE">
		<component name="Microsoft-Windows-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<ImageInstall>
				<OSImage>
					<Compact>false</Compact>
				</OSImage>
			</ImageInstall>
			<UserData>
				<ProductKey>
					<Key>00000-00000-00000-00000-00000</Key>
					<WillShowUI>Always</WillShowUI>
				</ProductKey>
				<AcceptEula>true</AcceptEula>
			</UserData>
			<UseConfigurationSet>false</UseConfigurationSet>
			<RunSynchronous>
				<RunSynchronousCommand wcm:action="add">
					<Order>1</Order>
					<Path>reg.exe add "HKLM\SYSTEM\Setup\LabConfig" /v BypassTPMCheck /t REG_DWORD /d 1 /f</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>2</Order>
					<Path>reg.exe add "HKLM\SYSTEM\Setup\LabConfig" /v BypassSecureBootCheck /t REG_DWORD /d 1 /f</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>3</Order>
					<Path>reg.exe add "HKLM\SYSTEM\Setup\LabConfig" /v BypassRAMCheck /t REG_DWORD /d 1 /f</Path>
				</RunSynchronousCommand>
			</RunSynchronous>
		</component>
	</settings>
	<settings pass="generalize"></settings>
	<settings pass="specialize">
		<component name="Microsoft-Windows-Deployment" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<RunSynchronous>
				<RunSynchronousCommand wcm:action="add">
					<Order>1</Order>
					<Path>powershell.exe -WindowStyle "Normal" -NoProfile -Command "$xml = [xml]::new(); $xml.Load('C:\Windows\Panther\unattend.xml'); $sb = [scriptblock]::Create( $xml.unattend.Extensions.ExtractScript ); Invoke-Command -ScriptBlock $sb -ArgumentList $xml;"</Path>
				</RunSynchronousCommand>
                <RunSynchronousCommand wcm:action="add">
					<Order>2</Order>
					<Path>powershell.exe -WindowStyle "Normal" -ExecutionPolicy "Unrestricted" -NoProfile -File "C:\Windows\Setup\Scripts\MySetup.ps1"</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>3</Order>
					<Path>powershell.exe -WindowStyle "Normal" -ExecutionPolicy "Unrestricted" -NoProfile -File "C:\MyMaintenance\Scripts\Specialize.ps1"</Path>
				</RunSynchronousCommand>
			</RunSynchronous>
		</component>
	</settings>
	<settings pass="auditSystem"></settings>
	<settings pass="auditUser"></settings>
	<settings pass="oobeSystem">
		<component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<OOBE>
				<ProtectYourPC>3</ProtectYourPC>
				<HideEULAPage>true</HideEULAPage>
				<HideWirelessSetupInOOBE>true</HideWirelessSetupInOOBE>
				<HideOnlineAccountScreens>true</HideOnlineAccountScreens>
			</OOBE>
		</component>
	</settings>
	<Extensions xmlns="https://schneegans.de/windows/unattend-generator/">
		<ExtractScript>
param(
    [xml] $Document
);

foreach( $file in $Document.unattend.Extensions.File ) {
    $path = [System.Environment]::ExpandEnvironmentVariables( $file.GetAttribute( 'path' ) );
    mkdir -Path( $path | Split-Path -Parent ) -ErrorAction 'SilentlyContinue';
    $encoding = switch( [System.IO.Path]::GetExtension( $path ) ) {
        { $_ -in '.ps1', '.xml' } { [System.Text.Encoding]::UTF8; }
        { $_ -in '.reg', '.vbs', '.js' } { [System.Text.UnicodeEncoding]::new( $false, $true ); }
        default { [System.Text.Encoding]::Default; }
    };
    $bytes = $encoding.GetPreamble() + $encoding.GetBytes( $file.InnerText.Trim() );
    [System.IO.File]::WriteAllBytes( $path, $bytes );
}
		</ExtractScript>
        <File path="C:\Windows\Setup\Scripts\MySetup.ps1">
<![CDATA[
# ============================================================
# MySetup.ps1
# Runs during SPECIALIZE pass
# Creates persistent setup folder structure and
# copies original Setup scripts for post-upgrade reuse.
# ============================================================

$MaintenanceRoot = "C:\MySetup"
$ScriptsDir = Join-Path $MaintenanceRoot "Scripts"
$LogDir          = Join-Path $MaintenanceRoot "Logs"
$StateDir        = Join-Path $MaintenanceRoot "State"

# --- Create folder structure ---
$folders = @(
    $ScriptsDir,
    $LogDir,
    $StateDir
)

foreach ($folder in $folders) {
    if (-not (Test-Path $folder)) {
        New-Item -Path $folder -ItemType Directory -Force | Out-Null
    }
}

# --- Copy original Setup scripts ---
$Source = "C:\Windows\Setup\Scripts"

if (Test-Path $Source) {
    Copy-Item -Path "$Source\*" -Destination $ScriptsDir -Recurse -Force -ErrorAction SilentlyContinue
} else {
    # Optional: log a warning if needed
}

# --- Store current OS build number ---
$Build = (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").CurrentBuildNumber
$Build | Out-File -FilePath (Join-Path $StateDir "LastBuild.txt") -Encoding ASCII -Force
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\Apply-Registry.ps1">
<![CDATA[
function Apply-RegistryEntry {
    param(
        [Parameter(Mandatory)]
        [string]$Path,

        [string]$Operation = "Set",
        [string]$Name,
        [ValidateSet("String","ExpandString","DWord","QWord","Binary","MultiString")]
        [string]$Type,
        $Value,
        [string]$Description = "",

        # For SetByte
        [int]$Offset,
        [byte]$ByteValue,

        # For SetBit
        [int]$BitIndex,
        [int]$BitValue
    )

    try {
        # Ensure key exists for operations that need it
        if ($Operation -notin @("Delete","EnsureKey") -and -not (Test-Path $Path)) {
            New-Item -Path $Path -Force | Out-Null
            Write-Output "[SUCCESS] Created key | Path='$Path' Description='$Description'"
        }

        switch ($Operation) {

            "EnsureKey" {
                if (-not (Test-Path $Path)) {
                    New-Item -Path $Path -Force | Out-Null
                    Write-Output "[SUCCESS] Created key | Path='$Path' Description='$Description'"
                }
                return
            }

            "Set" {
                if (-not $Name) { throw "Operation 'Set' requires a Name" }

                $exists = Get-ItemProperty -Path $Path -Name $Name -ErrorAction SilentlyContinue

                if ($exists) {
                    Set-ItemProperty -Path $Path -Name $Name -Value $Value -Force
                }
                else {
                    New-ItemProperty -Path $Path -Name $Name -Value $Value -PropertyType $Type -Force | Out-Null
                }

                Write-Output "[SUCCESS] $Description | Path='$Path' Name='$Name' Type='$Type' Value='$Value'"
            }

            "SetByte" {
                if (-not $Name) { throw "SetByte requires Name" }
                if ($Offset -lt 0) { throw "Offset must be >= 0" }

                $data = (Get-ItemProperty -Path $Path -Name $Name -ErrorAction Stop).$Name

                if ($data.Length -le $Offset) {
                    throw "Offset $Offset is outside data length $($data.Length)"
                }

                $data[$Offset] = $ByteValue

                Set-ItemProperty -Path $Path -Name $Name -Value $data -Force

                Write-Output "[SUCCESS] $Description | Modified byte $Offset of '$Path\$Name' to 0x{0:X2}" -f $ByteValue
            }

            "SetBit" {
                if (-not $Name) { throw "SetBit requires Name" }
                if ($Offset -lt 0) { throw "Offset must be >= 0" }
                if ($BitIndex -lt 0 -or $BitIndex -gt 7) { throw "BitIndex must be 0-7" }

                $data = (Get-ItemProperty -Path $Path -Name $Name -ErrorAction Stop).$Name

                if ($data.Length -le $Offset) {
                    throw "Offset $Offset is outside data length $($data.Length)"
                }

                $mask = 1 -shl $BitIndex

                if ($BitValue -eq 1) {
                    $data[$Offset] = $data[$Offset] -bor $mask
                }
                else {
                    $data[$Offset] = $data[$Offset] -band (-bnot $mask)
                }

                Set-ItemProperty -Path $Path -Name $Name -Value $data -Force

                Write-Output "[SUCCESS] $Description | Modified bit $BitIndex of byte $Offset in '$Path\$Name'"
            }
            
            "Delete" {
                if ($Name) {
                    if (Test-Path $Path) {
                        $exists = Get-ItemProperty -Path $Path -Name $Name -ErrorAction SilentlyContinue

                        if ($exists -ne $null) {
                            Remove-ItemProperty -Path $Path -Name $Name -Force
                            Write-Output "[SUCCESS] $Description | Deleted value '$Name' from '$Path'"
                        }
                        else {
                            Write-Output "[INFO] $Description | Value '$Name' does not exist at '$Path'"
                        }
                    }
                    else {
                        Write-Output "[INFO] $Description | Key '$Path' does not exist"
                    }
                }
                else {
                    if (Test-Path $Path) {
                        Remove-Item -Path $Path -Recurse -Force
                        Write-Output "[SUCCESS] $Description | Deleted key '$Path'"
                    }
                    else {
                        Write-Output "[INFO] $Description | Key '$Path' does not exist"
                    }
                }

                return
            }

            default {
                throw "Unknown operation '$Operation'"
            }
        }
    }
    catch {
        Write-Output "[ERROR] $Description | Failed at '$Path\$Name' : $($_.Exception.Message)"
    }
}

function Apply-RegistryBatch {
    param(
        [Parameter(Mandatory)]
        [array]$Items
    )

    foreach ($item in $Items) {
        Apply-RegistryEntry @item
    }
}
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\Specialize.ps1">
<![CDATA[
. "C:\MySetup\Scripts\Apply-Registry.ps1"

$scripts = @(
	{
		& "C:\MySetup\Scripts\DefaultUser.ps1"
	};
    {
        reg.exe load "HKU\DefaultUser" "C:\Users\Default\NTUSER.DAT"
        Apply-Registry -Path "HKU\DefaultUser\Software\Microsoft\Windows\CurrentVersion\RunOnce" `
            -Name "CurrentUser" `
            -Type "String" `
            -Value "powershell.exe -WindowStyle \""Normal\"" -ExecutionPolicy \""Unrestricted\"" -NoProfile -File \""C:\MyMaintenance\Scripts\UserOnce.ps1\"""
        reg.exe unload "HKU\DefaultUser"
    };
);

& {
  [float] $complete = 0;
  [float] $increment = 100 / $scripts.Count;
  foreach( $script in $scripts ) {
    Write-Progress -Activity 'Running scripts to customize your Windows installation. Do not close this window.' -PercentComplete $complete;
    "*** Will now execute command $([char]0xAB){0}$([char]0xBB)." -f $(
      $str = $script.ToString().Trim() -replace '\s+', ' ';
      $max = 100;
      if( $str.Length -le $max ) {
        $str;
      } else {
        $str.Substring( 0, $max - 1 ) + "$([char]0x2026)";
      }
    );
    $start = [datetime]::Now;
    & $script;
    '*** Finished executing command after {0:0} ms.' -f [datetime]::Now.Subtract( $start ).TotalMilliseconds;
    "`r`n" * 3;
    $complete += $increment;
  }
} *>&1 | Out-String -Width 1KB -Stream >> "C:\MySetup\Logs\Specialize.log";
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\DefaultUser.ps1">
<![CDATA[
$scripts = @(
	{
    
	};
);

& {
  [float] $complete = 0;
  [float] $increment = 100 / $scripts.Count;
  foreach( $script in $scripts ) {
    Write-Progress -Activity "Running scripts to modify the default user$([char]0x2019)$([char]0x2019)s registry hive. Do not close this window." -PercentComplete $complete;
    "*** Will now execute command $([char]0xAB){0}$([char]0xBB)." -f $(
      $str = $script.ToString().Trim() -replace '\s+', ' ';
      $max = 100;
      if( $str.Length -le $max ) {
        $str;
      } else {
        $str.Substring( 0, $max - 1 ) + "$([char]0x2026)";
      }
    );
    $start = [datetime]::Now;
    & $script;
    '*** Finished executing command after {0:0} ms.' -f [datetime]::Now.Subtract( $start ).TotalMilliseconds;
    "`r`n" * 3;
    $complete += $increment;
  }
} *>&1 | Out-String -Width 1KB -Stream >> "C:\MySetup\Logs\DefaultUser.log";
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\CurrentUser.ps1">
<![CDATA[
$logsDir = "$env:LOCALAPPDATA\MySetup"
if (-not (Test-Path $logsDir)) {
    New-Item -Path $logsDir -ItemType Directory -Force | Out-Null
}

$scripts = @(
	{
    
	};
);

& {
  [float] $complete = 0;
  [float] $increment = 100 / $scripts.Count;
  foreach( $script in $scripts ) {
    Write-Progress -Activity 'Running scripts to configure this user account. Do not close this window.' -PercentComplete $complete;
    "*** Will now execute command $([char]0xAB){0}$([char]0xBB)." -f $(
      $str = $script.ToString().Trim() -replace '\s+', ' ';
      $max = 100;
      if( $str.Length -le $max ) {
        $str;
      } else {
        $str.Substring( 0, $max - 1 ) + "$([char]0x2026)";
      }
    );
    $start = [datetime]::Now;
    & $script;
    '*** Finished executing command after {0:0} ms.' -f [datetime]::Now.Subtract( $start ).TotalMilliseconds;
    "`r`n" * 3;
    $complete += $increment;
  }
} *>&1 | Out-String -Width 1KB -Stream >> "$logsDir\CurrentUser.log";
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\PauseWindowsUpdate.ps1">
<![CDATA[
& {
    $formatter = {
        $args[0].ToString( "yyyy'-'MM'-'dd'T'HH':'mm':'ssK" );
    };
    $now = [datetime]::UtcNow;
    $start = & $formatter $now;
    $end = & $formatter $now.AddDays( 7.1 );

    $params = @{
        LiteralPath = 'Registry::HKLM\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings';
        Type = 'String';
        Force = $true;
    };

    Set-ItemProperty @params -Name 'PauseFeatureUpdatesStartTime' -Value $start;
    Set-ItemProperty @params -Name 'PauseFeatureUpdatesEndTime' -Value $end;
    Set-ItemProperty @params -Name 'PauseQualityUpdatesStartTime' -Value $start;
    Set-ItemProperty @params -Name 'PauseQualityUpdatesEndTime' -Value $end;
    Set-ItemProperty @params -Name 'PauseUpdatesStartTime' -Value $start;
    Set-ItemProperty @params -Name 'PauseUpdatesExpiryTime' -Value $end;
} *>&1 | Out-String -Width 1KB -Stream >> "C:\MySetup\Logs\PauseWindowsUpdate.log";
]]>
		</File>
		<File path="C:\Windows\Setup\Scripts\PauseWindowsUpdate.xml">
<![CDATA[
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <CalendarTrigger>
      <StartBoundary>2026-01-01T12:00:00-08:00</StartBoundary>
      <Enabled>true</Enabled>
      <ScheduleByDay>
        <DaysInterval>1</DaysInterval>
      </ScheduleByDay>
    </CalendarTrigger>
    <BootTrigger>
      <Enabled>true</Enabled>
    </BootTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <Enabled>true</Enabled>
    <Hidden>false</Hidden>
    <RunOnlyIfIdle>false</RunOnlyIfIdle>
    <WakeToRun>true</WakeToRun>
    <ExecutionTimeLimit>PT5M</ExecutionTimeLimit>
    <Priority>7</Priority>
    <RestartOnFailure>
      <Interval>PT5M</Interval>
      <Count>5</Count>
    </RestartOnFailure>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</Command>
      <Arguments>-ExecutionPolicy "Unrestricted" -NoProfile -File "C:\MySetup\Scripts\PauseWindowsUpdate.ps1"</Arguments>
    </Exec>
  </Actions>
</Task>
]]>
		</File>
        <File path="C:\Windows\Setup\Scripts\MoveActiveHours.vbs">
<![CDATA[
HKLM = &H80000002
key = "SOFTWARE\Microsoft\WindowsUpdate\UX\Settings"
Set reg = GetObject("winmgmts://./root/default:StdRegProv")
current = Hour(Now)
reg.SetDWORDValue HKLM, key, "ActiveHoursStart", ( current + 23 ) Mod 24
reg.SetDWORDValue HKLM, key, "ActiveHoursEnd", ( current + 11 ) Mod 24
reg.SetDWORDValue HKLM, key, "SmartActiveHoursState", 2
]]>
		</File>
		<File path="C:\Windows\Setup\Scripts\MoveActiveHoursPrimary.xml">
<![CDATA[
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <BootTrigger>
      <Enabled>true</Enabled>
    </BootTrigger>
    <CalendarTrigger>
      <StartBoundary>2026-01-01T00:00:00</StartBoundary>
      <Enabled>true</Enabled>
      <ScheduleByDay>
        <DaysInterval>1</DaysInterval>
      </ScheduleByDay>
      <Repetition>
        <Interval>PT4H</Interval>
        <StopAtDurationEnd>false</StopAtDurationEnd>
      </Repetition>
    </CalendarTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <Enabled>true</Enabled>
    <Hidden>false</Hidden>
    <RunOnlyIfIdle>false</RunOnlyIfIdle>
    <WakeToRun>false</WakeToRun>
    <ExecutionTimeLimit>PT5M</ExecutionTimeLimit>
    <Priority>7</Priority>
    <RestartOnFailure>
      <Interval>PT5M</Interval>
      <Count>5</Count>
    </RestartOnFailure>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>C:\Windows\System32\wscript.exe</Command>
      <Arguments>"C:\MySetup\Scripts\MoveActiveHours.vbs" >> "C:\MySetup\Logs\MoveActiveHours.log" 2>&1</Arguments>
    </Exec>
  </Actions>
</Task>
]]>
		</File>
        <File path="C:\Windows\Setup\Scripts\MoveActiveHoursBackup.xml">
<![CDATA[
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <BootTrigger>
      <Enabled>true</Enabled>
    </BootTrigger>
    <CalendarTrigger>
      <StartBoundary>2026-01-01T00:05:00</StartBoundary>
      <Enabled>true</Enabled>
      <ScheduleByDay>
        <DaysInterval>1</DaysInterval>
      </ScheduleByDay>
      <Repetition>
        <Interval>PT8H</Interval>
        <StopAtDurationEnd>false</StopAtDurationEnd>
      </Repetition>
    </CalendarTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <Enabled>true</Enabled>
    <Hidden>false</Hidden>
    <RunOnlyIfIdle>false</RunOnlyIfIdle>
    <WakeToRun>true</WakeToRun>
    <ExecutionTimeLimit>PT5M</ExecutionTimeLimit>
    <Priority>7</Priority>
    <RestartOnFailure>
      <Interval>PT5M</Interval>
      <Count>5</Count>
    </RestartOnFailure>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>C:\Windows\System32\wscript.exe</Command>
      <Arguments>"C:\MySetup\Scripts\MoveActiveHours.vbs" >> "C:\MySetup\Logs\MoveActiveHours.log" 2>&1</Arguments>
    </Exec>
  </Actions>
</Task>
]]>
		</File>
    </Extensions>
</unattend>