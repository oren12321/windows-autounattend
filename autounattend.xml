<?xml version="1.0" encoding="utf-8"?>
<unattend xmlns="urn:schemas-microsoft-com:unattend" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State">
	<settings pass="offlineServicing"></settings>
	<settings pass="windowsPE">
		<component name="Microsoft-Windows-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<ImageInstall>
				<OSImage>
					<Compact>false</Compact>
				</OSImage>
			</ImageInstall>
			<UserData>
				<ProductKey>
					<Key>00000-00000-00000-00000-00000</Key>
					<WillShowUI>Always</WillShowUI>
				</ProductKey>
				<AcceptEula>true</AcceptEula>
			</UserData>
			<UseConfigurationSet>false</UseConfigurationSet>
			<RunSynchronous>
				<RunSynchronousCommand wcm:action="add">
					<Order>1</Order>
					<Path>reg.exe add "HKLM\SYSTEM\Setup\LabConfig" /v BypassTPMCheck /t REG_DWORD /d 1 /f</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>2</Order>
					<Path>reg.exe add "HKLM\SYSTEM\Setup\LabConfig" /v BypassSecureBootCheck /t REG_DWORD /d 1 /f</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>3</Order>
					<Path>reg.exe add "HKLM\SYSTEM\Setup\LabConfig" /v BypassRAMCheck /t REG_DWORD /d 1 /f</Path>
				</RunSynchronousCommand>
			</RunSynchronous>
		</component>
	</settings>
	<settings pass="generalize"></settings>
	<settings pass="specialize">
		<component name="Microsoft-Windows-Deployment" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<RunSynchronous>
				<RunSynchronousCommand wcm:action="add">
					<Order>1</Order>
					<Path>powershell.exe -WindowStyle "Normal" -NoProfile -Command "$xml = [xml]::new(); $xml.Load('C:\Windows\Panther\unattend.xml'); $sb = [scriptblock]::Create( $xml.unattend.Extensions.ExtractScript ); Invoke-Command -ScriptBlock $sb -ArgumentList $xml;"</Path>
				</RunSynchronousCommand>
                <RunSynchronousCommand wcm:action="add">
					<Order>2</Order>
					<Path>powershell.exe -WindowStyle "Normal" -ExecutionPolicy "Unrestricted" -NoProfile -File "C:\Windows\Setup\Scripts\MySetup.ps1"</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>3</Order>
					<Path>powershell.exe -WindowStyle "Normal" -ExecutionPolicy "Unrestricted" -NoProfile -File "C:\MySetup\Scripts\Specialize.ps1"</Path>
				</RunSynchronousCommand>
                <RunSynchronousCommand wcm:action="add">
					<Order>4</Order>
					<Path>powershell.exe -WindowStyle "Normal" -ExecutionPolicy "Unrestricted" -NoProfile -File "C:\MySetup\Scripts\DefaultUser.ps1"</Path>
				</RunSynchronousCommand>
			</RunSynchronous>
		</component>
	</settings>
	<settings pass="auditSystem"></settings>
	<settings pass="auditUser"></settings>
	<settings pass="oobeSystem">
		<component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<OOBE>
				<ProtectYourPC>3</ProtectYourPC>
				<HideEULAPage>true</HideEULAPage>
				<HideWirelessSetupInOOBE>true</HideWirelessSetupInOOBE>
				<HideOnlineAccountScreens>true</HideOnlineAccountScreens>
			</OOBE>
		</component>
	</settings>
	<Extensions xmlns="https://schneegans.de/windows/unattend-generator/">
		<ExtractScript>
param(
    [xml] $Document
);

foreach( $file in $Document.unattend.Extensions.File ) {
    $path = [System.Environment]::ExpandEnvironmentVariables( $file.GetAttribute( 'path' ) );
    mkdir -Path( $path | Split-Path -Parent ) -ErrorAction 'SilentlyContinue';
    $encoding = switch( [System.IO.Path]::GetExtension( $path ) ) {
        { $_ -in '.ps1', '.xml' } { [System.Text.Encoding]::UTF8; }
        { $_ -in '.reg', '.vbs', '.js' } { [System.Text.UnicodeEncoding]::new( $false, $true ); }
        default { [System.Text.Encoding]::Default; }
    };
    $bytes = $encoding.GetPreamble() + $encoding.GetBytes( $file.InnerText.Trim() );
    [System.IO.File]::WriteAllBytes( $path, $bytes );
}
		</ExtractScript>
        <File path="C:\Windows\Setup\Scripts\MySetup.ps1">
<![CDATA[
# ============================================================
# MySetup.ps1
# Runs during SPECIALIZE pass
# Creates persistent setup folder structure and
# copies original Setup scripts for post-upgrade reuse.
# ============================================================

$SetupDir = "C:\MySetup"
$ScriptsDir = Join-Path $SetupDir "Scripts"
$LogDir          = Join-Path $SetupDir "Logs"
$StateDir        = Join-Path $SetupDir "State"

# --- Create folder structure ---
$folders = @(
    $ScriptsDir,
    $LogDir,
    $StateDir
)

foreach ($folder in $folders) {
    if (-not (Test-Path $folder)) {
        New-Item -Path $folder -ItemType Directory -Force | Out-Null
    }
}

# --- Copy original Setup scripts ---
$Source = "C:\Windows\Setup\Scripts"

if (Test-Path $Source) {
    Copy-Item -Path "$Source\*" -Destination $ScriptsDir -Recurse -Force -ErrorAction SilentlyContinue
} else {
    # Optional: log a warning if needed
}

# --- Store current OS build number ---
$Build = (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").CurrentBuildNumber
$Build | Out-File -FilePath (Join-Path $StateDir "LastBuild.txt") -Encoding ASCII -Force
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\Apply-Registry.ps1">
<![CDATA[
function Apply-RegistryEntry {
    param(
        [Parameter(Mandatory)]
        [string]$Path,

        [string]$Operation = "Set",
        [string]$Name,
        [ValidateSet("String","ExpandString","DWord","QWord","Binary","MultiString")]
        [string]$Type,
        $Value,
        [string]$Description = "",

        # For SetByte
        [int]$Offset,
        [byte]$ByteValue,

        # For SetBit
        [int]$BitIndex,
        [int]$BitValue
    )

    try {
        # Ensure key exists for operations that need it
        if ($Operation -notin @("Delete","EnsureKey") -and -not (Test-Path $Path)) {
            New-Item -Path $Path -Force | Out-Null
            Write-Output "[SUCCESS] Created key | Path='$Path' Description='$Description'"
        }

        switch ($Operation) {

            "EnsureKey" {
                if (-not (Test-Path $Path)) {
                    New-Item -Path $Path -Force | Out-Null
                    Write-Output "[SUCCESS] Created key | Path='$Path' Description='$Description'"
                }
                return
            }

            "Set" {
                if (-not $Name) { throw "Operation 'Set' requires a Name" }

                $exists = Get-ItemProperty -Path $Path -Name $Name -ErrorAction SilentlyContinue

                if ($exists) {
                    Set-ItemProperty -Path $Path -Name $Name -Value $Value -Force
                }
                else {
                    New-ItemProperty -Path $Path -Name $Name -Value $Value -PropertyType $Type -Force | Out-Null
                }

                Write-Output "[SUCCESS] $Description | Path='$Path' Name='$Name' Type='$Type' Value='$Value'"
            }

            "SetByte" {
                if (-not $Name) { throw "SetByte requires Name" }
                if ($Offset -lt 0) { throw "Offset must be >= 0" }

                $data = (Get-ItemProperty -Path $Path -Name $Name -ErrorAction Stop).$Name

                if ($data.Length -le $Offset) {
                    throw "Offset $Offset is outside data length $($data.Length)"
                }

                $data[$Offset] = $ByteValue

                Set-ItemProperty -Path $Path -Name $Name -Value $data -Force

                Write-Output "[SUCCESS] $Description | Modified byte $Offset of '$Path\$Name' to 0x{0:X2}" -f $ByteValue
            }

            "SetBit" {
                if (-not $Name) { throw "SetBit requires Name" }
                if ($Offset -lt 0) { throw "Offset must be >= 0" }
                if ($BitIndex -lt 0 -or $BitIndex -gt 7) { throw "BitIndex must be 0-7" }

                $data = (Get-ItemProperty -Path $Path -Name $Name -ErrorAction Stop).$Name

                if ($data.Length -le $Offset) {
                    throw "Offset $Offset is outside data length $($data.Length)"
                }

                $mask = 1 -shl $BitIndex

                if ($BitValue -eq 1) {
                    $data[$Offset] = $data[$Offset] -bor $mask
                }
                else {
                    $data[$Offset] = $data[$Offset] -band (-bnot $mask)
                }

                Set-ItemProperty -Path $Path -Name $Name -Value $data -Force

                Write-Output "[SUCCESS] $Description | Modified bit $BitIndex of byte $Offset in '$Path\$Name'"
            }
            
            "Delete" {
                if ($Name) {
                    if (Test-Path $Path) {
                        $exists = Get-ItemProperty -Path $Path -Name $Name -ErrorAction SilentlyContinue

                        if ($exists -ne $null) {
                            Remove-ItemProperty -Path $Path -Name $Name -Force
                            Write-Output "[SUCCESS] $Description | Deleted value '$Name' from '$Path'"
                        }
                        else {
                            Write-Output "[INFO] $Description | Value '$Name' does not exist at '$Path'"
                        }
                    }
                    else {
                        Write-Output "[INFO] $Description | Key '$Path' does not exist"
                    }
                }
                else {
                    if (Test-Path $Path) {
                        Remove-Item -Path $Path -Recurse -Force
                        Write-Output "[SUCCESS] $Description | Deleted key '$Path'"
                    }
                    else {
                        Write-Output "[INFO] $Description | Key '$Path' does not exist"
                    }
                }

                return
            }

            default {
                throw "Unknown operation '$Operation'"
            }
        }
    }
    catch {
        Write-Output "[ERROR] $Description | Failed at '$Path\$Name' : $($_.Exception.Message)"
    }
}

function Apply-RegistryBatch {
    param(
        [Parameter(Mandatory)]
        [array]$Items
    )

    foreach ($item in $Items) {
        Apply-RegistryEntry @item
    }
}
]]>
        </File>
        <File path="C:\Users\Default\AppData\Local\Microsoft\Windows\Shell\LayoutModification.xml">
<![CDATA[
<LayoutModificationTemplate Version="1" xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification">
	<LayoutOptions StartTileGroupCellWidth="6" />
	<DefaultLayoutOverride>
		<StartLayoutCollection>
			<StartLayout GroupCellWidth="6" xmlns="http://schemas.microsoft.com/Start/2014/FullDefaultLayout" />
		</StartLayoutCollection>
	</DefaultLayoutOverride>
</LayoutModificationTemplate>
]]>
		</File>
        <File path="C:\Windows\Setup\Scripts\Specialize.ps1">
<![CDATA[
$scripts = @(
    {
        & "C:\MySetup\Scripts\Debloat.ps1"
    };
    {
        & "C:\MySetup\Scripts\ConfigurePowerSettings.System.ps1" >> "C:\MySetup\Logs\ConfigurePowerSettings.System.log" 2>&1
    };
    {
        & "C:\MySetup\Scripts\ConfigureWindowsUpdate.System.ps1" >> "C:\MySetup\Logs\ConfigureWindowsUpdate.System.log" 2>&1
    };
    {
        & "C:\MySetup\Scripts\ConfigureWindowsAI.System.ps1" >> "C:\MySetup\Logs\ConfigureWindowsAI.System.log" 2>&1
    };
    {
        & "C:\MySetup\Scripts\ConfigureSecurityAndPrivacy.System.ps1" >> "C:\MySetup\Logs\ConfigureSecurityAndPrivacy.System.log" 2>&1
    };
    {
        & "C:\MySetup\Scripts\ConfigurePerformance.System.ps1" >> "C:\MySetup\Scripts\ConfigurePerformance.System.log" 2>&1
    };
    {
        # First user logon schedule task registration
        Register-ScheduledTask -TaskName 'UserSetup.FirstUser' -Xml $( Get-Content -LiteralPath 'C:\MySetup\Scripts\UserSetup.FirstUser.xml' -Raw );
    };
    {
        # Per user Active Setup
        & "C:\MySetup\Scripts\ConfigureActiveSetup.ps1" >> "C:\MySetup\Logs\ConfigureActiveSetup.log" 2>&1
    };
);

& {
  [float] $complete = 0;
  [float] $increment = 100 / $scripts.Count;
  foreach( $script in $scripts ) {
    Write-Progress -Activity 'Running scripts to customize your Windows installation. Do not close this window.' -PercentComplete $complete;
    "*** Will now execute command $([char]0xAB){0}$([char]0xBB)." -f $(
      $str = $script.ToString().Trim() -replace '\s+', ' ';
      $max = 100;
      if( $str.Length -le $max ) {
        $str;
      } else {
        $str.Substring( 0, $max - 1 ) + "$([char]0x2026)";
      }
    );
    $start = [datetime]::Now;
    & $script;
    '*** Finished executing command after {0:0} ms.' -f [datetime]::Now.Subtract( $start ).TotalMilliseconds;
    "`r`n" * 3;
    $complete += $increment;
  }
} *>&1 | Out-String -Width 1KB -Stream >> "C:\MySetup\Logs\Specialize.log";
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\DefaultUser.ps1">
<![CDATA[
. "C:\MySetup\Scripts\Apply-Registry.ps1"

$scripts = @(
    {
        reg.exe load "HKU\DefaultUser" "C:\Users\Default\NTUSER.DAT"
    };
    {
        # SOME DEFAULT USER MODIFICATIONS
    };
    {
        reg.exe unload "HKU\DefaultUser"
    };
);

& {
  [float] $complete = 0;
  [float] $increment = 100 / $scripts.Count;
  foreach( $script in $scripts ) {
    Write-Progress -Activity "Running scripts to modify the default user$([char]0x2019)$([char]0x2019)s registry hive. Do not close this window." -PercentComplete $complete;
    "*** Will now execute command $([char]0xAB){0}$([char]0xBB)." -f $(
      $str = $script.ToString().Trim() -replace '\s+', ' ';
      $max = 100;
      if( $str.Length -le $max ) {
        $str;
      } else {
        $str.Substring( 0, $max - 1 ) + "$([char]0x2026)";
      }
    );
    $start = [datetime]::Now;
    & $script;
    '*** Finished executing command after {0:0} ms.' -f [datetime]::Now.Subtract( $start ).TotalMilliseconds;
    "`r`n" * 3;
    $complete += $increment;
  }
} *>&1 | Out-String -Width 1KB -Stream >> "C:\MySetup\Logs\DefaultUser.log";
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\UserSetup.ps1">
<![CDATA[
param(
    [string]$Mode  # "FirstUser" or "PerUser"
)

$logFile = "C:\MySetup\Logs\UserSetup.log"

# Logging helper
function Write-Log {
    param([string]$Message)
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    "$timestamp | $Message" | Out-File $logFile -Append
}

Write-Log "Starting UserSetup.ps1 with Mode='$Mode'"

switch ($Mode) {

    "FirstUser" {
        Write-Log "Executing FirstUser mode"
    
        try {
            # Things ONLY the first user should get
            # Example: OEM branding, one-time app installs, etc.
            & "C:\MySetup\Scripts\UserSetup.FirstUser.ps1"
        }
        catch {
            Write-Log "ERROR in FirstUser script: $_"
        }
        
        # Remove the scheduled task so it never runs again
        $taskName = "UserSetup.FirstUser"
        
        try {
            if (Get-ScheduledTask -TaskName $taskName -ErrorAction SilentlyContinue) {
                Write-Log "Removing scheduled task '$taskName'"
                Unregister-ScheduledTask -TaskName $taskName -Confirm:$false
            }
            else {
                Write-Log "No scheduled task '$taskName' to remove"
            }
        }
        catch {
            Write-Log "ERROR in '$taskName' schedule task removal: $_"
        }
    }

    "PerUser" {
        Write-Log "Executing PerUser mode"
    
        try {
            # Things EVERY user should get
            # Example: Explorer defaults, Taskbar tweaks, Start menu tweaks
            & "C:\MySetup\Scripts\UserSetup.PerUser.ps1"
        }
        catch {
            Write-Log "ERROR in PerUser script: $_"
        }
    }
    
    default {
        Write-Log "WARNING: Invalid mode '$Mode'. Expected 'FirstUser' or 'PerUser'."
        return
    }
}

Write-Log "UserSetup.ps1 finished"
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\UserSetup.FirstUser.ps1">
<![CDATA[
$logsDir = "$env:LOCALAPPDATA\MySetup"
if (-not (Test-Path $logsDir)) {
    New-Item -Path $logsDir -ItemType Directory -Force | Out-Null
}

$scripts = @(
	{
    
	};
);

& {
  [float] $complete = 0;
  [float] $increment = 100 / $scripts.Count;
  foreach( $script in $scripts ) {
    Write-Progress -Activity 'Running scripts to configure this user account. Do not close this window.' -PercentComplete $complete;
    "*** Will now execute command $([char]0xAB){0}$([char]0xBB)." -f $(
      $str = $script.ToString().Trim() -replace '\s+', ' ';
      $max = 100;
      if( $str.Length -le $max ) {
        $str;
      } else {
        $str.Substring( 0, $max - 1 ) + "$([char]0x2026)";
      }
    );
    $start = [datetime]::Now;
    & $script;
    '*** Finished executing command after {0:0} ms.' -f [datetime]::Now.Subtract( $start ).TotalMilliseconds;
    "`r`n" * 3;
    $complete += $increment;
  }
} *>&1 | Out-String -Width 1KB -Stream >> "$logsDir\UserSetup.FirstUser.log";
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\UserSetup.PerUser.ps1">
<![CDATA[
$logsDir = "$env:LOCALAPPDATA\MySetup"
if (-not (Test-Path $logsDir)) {
    New-Item -Path $logsDir -ItemType Directory -Force | Out-Null
}

$scripts = @(
	{
    
	};
);

& {
  [float] $complete = 0;
  [float] $increment = 100 / $scripts.Count;
  foreach( $script in $scripts ) {
    Write-Progress -Activity 'Running scripts to configure this user account. Do not close this window.' -PercentComplete $complete;
    "*** Will now execute command $([char]0xAB){0}$([char]0xBB)." -f $(
      $str = $script.ToString().Trim() -replace '\s+', ' ';
      $max = 100;
      if( $str.Length -le $max ) {
        $str;
      } else {
        $str.Substring( 0, $max - 1 ) + "$([char]0x2026)";
      }
    );
    $start = [datetime]::Now;
    & $script;
    '*** Finished executing command after {0:0} ms.' -f [datetime]::Now.Subtract( $start ).TotalMilliseconds;
    "`r`n" * 3;
    $complete += $increment;
  }
} *>&1 | Out-String -Width 1KB -Stream >> "$logsDir\UserSetup.PerUser.log";
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\ConfigureActiveSetup.ps1">
<![CDATA[
. "C:\MySetup\Scripts\Apply-Registry.ps1"

Write-Output "Starting Active Setup registration"

$entries = @(
    @{
        Path = "HKLM:\Software\Microsoft\Active Setup\Installed Components\UserSetup.PerUser"
        Name = "Version"
        Type = "String"
        Value = "1,0,0,0"
    },
    @{
        Path = "HKLM:\Software\Microsoft\Active Setup\Installed Components\UserSetup.PerUser"
        Name = "StubPath"
        Type = "String"
        Value = "powershell.exe -NoProfile -ExecutionPolicy Bypass -File ""C:\MySetup\Scripts\UserSetup.ps1"" PerUser"
    },
    @{
        Path = "HKLM:\Software\Microsoft\Active Setup\Installed Components\UserSetup.PerUser"
        Name = "Locale"
        Type = "String"
        Value = "*"
    },
    @{
        Path = "HKLM:\Software\Microsoft\Active Setup\Installed Components\UserSetup.PerUser"
        Name = "IsInstalled"
        Type = "DWord"
        Value = 1
    }
)
Apply-RegistryBatch $entries

Write-Output "Active Setup registration done"
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\Debloat.ps1">
<![CDATA[
& "C:\MySetup\Scripts\RemovePackages.ps1"
& "C:\MySetup\Scripts\RemoveCapabilities.ps1"
& "C:\MySetup\Scripts\RemoveFeatures.ps1"
& "C:\MySetup\Scripts\RemoveOneDrive.ps1" >> "C:\MySetup\Logs\RemoveOneDrive.log" 2>&1
& "C:\MySetup\Scripts\RemoveEdge.ps1" >> "C:\MySetup\Logs\RemoveEdge.log" 2>&1
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\RemovePackages.ps1">
<![CDATA[
$selectors = @(
	'Microsoft.Microsoft3DViewer';
	'Microsoft.BingSearch';
	'Clipchamp.Clipchamp';
	'Microsoft.Copilot';
	'Microsoft.549981C3F5F10';
	'Microsoft.Windows.DevHome';
	'MicrosoftCorporationII.MicrosoftFamily';
	'Microsoft.WindowsFeedbackHub';
	'Microsoft.Edge.GameAssist';
	'Microsoft.GetHelp';
	'Microsoft.Getstarted';
	'microsoft.windowscommunicationsapps';
	'Microsoft.WindowsMaps';
	'Microsoft.MixedReality.Portal';
	'Microsoft.BingNews';
	'Microsoft.MicrosoftOfficeHub';
	'Microsoft.Office.OneNote';
	'Microsoft.OutlookForWindows';
	'Microsoft.MSPaint';
	'Microsoft.People';
	'Microsoft.PowerAutomateDesktop';
	'MicrosoftCorporationII.QuickAssist';
	'Microsoft.SkypeApp';
	'Microsoft.MicrosoftSolitaireCollection';
	'Microsoft.MicrosoftStickyNotes';
	'MicrosoftTeams';
	'MSTeams';
	'Microsoft.Todos';
	'Microsoft.Wallet';
	'Microsoft.BingWeather';
	'Microsoft.Xbox.TCUI';
	'Microsoft.XboxApp';
	'Microsoft.XboxGameOverlay';
	'Microsoft.XboxGamingOverlay';
	'Microsoft.XboxIdentityProvider';
	'Microsoft.XboxSpeechToTextOverlay';
	'Microsoft.GamingApp';
	'Microsoft.YourPhone';
	'Microsoft.ZuneVideo';
);
$getCommand = {
  Get-AppxProvisionedPackage -Online;
};
$filterCommand = {
  $_.DisplayName -like "*$selector*";
};
$removeCommand = {
  [CmdletBinding()]
  param(
    [Parameter( Mandatory, ValueFromPipeline )]
    $InputObject
  );
  process {
    $InputObject | Remove-AppxProvisionedPackage -AllUsers -Online -ErrorAction 'Continue';
    
    $PFN = (Get-AppxPackage -Name $InputObject.DisplayName -AllUsers).PackageFamilyName

    if ($PFN) {
        $RegPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore\Deprovisioned\$PFN"
        if (!(Test-Path $RegPath)) {
            # Use | Out-Null to prevent this from being captured by $result.Output
            New-Item -Path $RegPath -Force | Out-Null
        }
    }
  }
};
$type = 'Package';
$logfile = 'C:\MySetup\Logs\RemovePackages.log';
& {
	$installed = & $getCommand;
	foreach( $selector in $selectors ) {
		$result = [ordered] @{
			Selector = $selector;
		};
		$found = $installed | Where-Object -FilterScript $filterCommand;
		if( $found ) {
			$result.Output = $found | & $removeCommand;
			if( $? ) {
				$result.Message = "$type removed.";
			} else {
				$result.Message = "$type not removed.";
				$result.Error = $Error[0];
			}
		} else {
			$result.Message = "$type not installed.";
		}
		$result | ConvertTo-Json -Depth 3 -Compress;
	}
} *>&1 | Out-String -Width 1KB -Stream >> $logfile;
]]>
		</File>
		<File path="C:\Windows\Setup\Scripts\RemoveCapabilities.ps1">
<![CDATA[
$selectors = @(
	'Print.Fax.Scan';
	'Language.Handwriting';
	'MathRecognizer';
	'OneCoreUAP.OneSync';
	'Microsoft.Windows.PowerShell.ISE';
	'App.Support.QuickAssist';
	'Language.Speech';
	'Language.TextToSpeech';
	'App.StepsRecorder';
	'Hello.Face.18967';
	'Hello.Face.Migration.18967';
	'Hello.Face.20134';
	'Media.WindowsMediaPlayer';
	'Microsoft.Windows.WordPad';
);
$getCommand = {
  Get-WindowsCapability -Online | Where-Object -Property 'State' -NotIn -Value @(
    'NotPresent';
    'Removed';
  );
};
$filterCommand = {
  ($_.Name -split '~')[0] -eq $selector;
};
$removeCommand = {
  [CmdletBinding()]
  param(
    [Parameter( Mandatory, ValueFromPipeline )]
    $InputObject
  );
  process {
    $InputObject | Remove-WindowsCapability -Online -ErrorAction 'Continue';
  }
};
$type = 'Capability';
$logfile = 'C:\MySetup\Logs\RemoveCapabilities.log';
& {
	$installed = & $getCommand;
	foreach( $selector in $selectors ) {
		$result = [ordered] @{
			Selector = $selector;
		};
		$found = $installed | Where-Object -FilterScript $filterCommand;
		if( $found ) {
			$result.Output = $found | & $removeCommand;
			if( $? ) {
				$result.Message = "$type removed.";
			} else {
				$result.Message = "$type not removed.";
				$result.Error = $Error[0];
			}
		} else {
			$result.Message = "$type not installed.";
		}
		$result | ConvertTo-Json -Depth 3 -Compress;
	}
} *>&1 | Out-String -Width 1KB -Stream >> $logfile;
]]>
		</File>
		<File path="C:\Windows\Setup\Scripts\RemoveFeatures.ps1">
<![CDATA[
$selectors = @(
	'Microsoft-RemoteDesktopConnection';
	'Recall';
);
$getCommand = {
  Get-WindowsOptionalFeature -Online | Where-Object -Property 'State' -NotIn -Value @(
    'Disabled';
    'DisabledWithPayloadRemoved';
  );
};
$filterCommand = {
  $_.FeatureName -eq $selector;
};
$removeCommand = {
  [CmdletBinding()]
  param(
    [Parameter( Mandatory, ValueFromPipeline )]
    $InputObject
  );
  process {
    $InputObject | Disable-WindowsOptionalFeature -Online -Remove -NoRestart -ErrorAction 'Continue';
  }
};
$type = 'Feature';
$logfile = 'C:\MySetup\Logs\RemoveFeatures.log';
& {
	$installed = & $getCommand;
	foreach( $selector in $selectors ) {
		$result = [ordered] @{
			Selector = $selector;
		};
		$found = $installed | Where-Object -FilterScript $filterCommand;
		if( $found ) {
			$result.Output = $found | & $removeCommand;
			if( $? ) {
				$result.Message = "$type removed.";
			} else {
				$result.Message = "$type not removed.";
				$result.Error = $Error[0];
			}
		} else {
			$result.Message = "$type not installed.";
		}
		$result | ConvertTo-Json -Depth 3 -Compress;
	}
} *>&1 | Out-String -Width 1KB -Stream >> $logfile;
]]>
		</File>
        <File path="C:\Windows\Setup\Scripts\RemoveOneDrive.ps1">
<![CDATA[
<#
  .SYNOPSIS
      Removes Microsoft OneDrive from Windows 10/11 systems.

  .DESCRIPTION
      This script detects and removes Microsoft OneDrive installations including:
      - Registry-based uninstallation using the user's HKU uninstall entry
      - OneDrive files and folders from the current users' AppData folder. (NOTE: Userdata in %USERPROFILE%\OneDrive is preserved)
      - System-wide OneDrive installation files
      - OneDrive scheduled tasks
      - Start Menu shortcuts
      - Default user profile configuration to prevent auto-installation

      This script is designed to run in any context: user sessions, SYSTEM account, or scheduled tasks.

  .NOTES
      Source: https://github.com/memstechtips/Winhance

      Requirements:
      - Windows 10/11
      - Administrator privileges (script will auto-elevate)
      - PowerShell 5.1 or higher
      
      Refined by additional guards to prevent reinstallation
#>

# Check if script is running as Administrator
If (!([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]"Administrator")) {
    Try {
        Start-Process PowerShell.exe -ArgumentList ("-NoProfile -ExecutionPolicy Bypass -File `"{0}`"" -f $PSCommandPath) -Verb RunAs
        Exit
    }
    Catch {
        Write-Output "Failed to run as Administrator. Please rerun with elevated privileges."
        Exit
    }
}

Write-Output "Starting OneDrive removal process"

# Get the interactive user when running as SYSTEM (not needed for regular user execution)
function Get-TargetUser {
    Write-Output "Get-TargetUser: Starting user detection"

    # Try interactive user first
    try {
        $user = Get-WmiObject Win32_ComputerSystem | Select-Object -ExpandProperty UserName
        Write-Output "Get-TargetUser: Win32_ComputerSystem returned: '$user'"
        if ($user -and $user -ne "NT AUTHORITY\SYSTEM") {
            $username = $user.Split('\')[1]
            Write-Output "Get-TargetUser: Extracted username: '$username'"
            return $username
        }
        Write-Output "Get-TargetUser: User is null or SYSTEM, trying fallback method"
    }
    catch {
        Write-Output "Get-TargetUser: Win32_ComputerSystem failed: $($_.Exception.Message)"
    }

    # Fallback: find user running explorer.exe
    try {
        $explorer = Get-Process explorer -ErrorAction SilentlyContinue | Select-Object -First 1
        Write-Output "Get-TargetUser: Explorer process found: $($explorer -ne $null)"
        if ($explorer) {
            $owner = $explorer.GetOwner()
            Write-Output "Get-TargetUser: Explorer owner: Domain='$($owner.Domain)', User='$($owner.User)'"
            return $owner.User
        }
        Write-Output "Get-TargetUser: No explorer process found"
    }
    catch {
        Write-Output "Get-TargetUser: Explorer method failed: $($_.Exception.Message)"
    }

    Write-Output "Get-TargetUser: No user found, returning null"
    return $null
}

# Get the user's SID for registry access
function Get-UserSID {
    param($Username)
    try {
        $user = New-Object System.Security.Principal.NTAccount($Username)
        return $user.Translate([System.Security.Principal.SecurityIdentifier]).Value
    }
    catch {
        Write-Output "Get-UserSID: Failed for user '$Username': $($_.Exception.Message)"
        return $null
    }
}

# Determine user profile to check
Write-Output "Current environment: USERNAME='$env:USERNAME', USERPROFILE='$env:USERPROFILE'"

if ($env:USERNAME -eq "SYSTEM" -or $env:USERNAME -like "*$" -or $env:USERPROFILE -like "*\system32\config\systemprofile") {
    Write-Output "Running as SYSTEM, attempting to detect target user"
    $targetUser = Get-TargetUser
    if ($targetUser) {
        $userProfilePath = "C:\Users\$targetUser"
        Write-Output "Running as SYSTEM, targeting user: '$targetUser', profile path: '$userProfilePath'"
    } else {
        Write-Output "Running as SYSTEM but no target user found"
        $userProfilePath = $null
    }
} else {
    $targetUser = $env:USERNAME
    $userProfilePath = $env:USERPROFILE
    Write-Output "Running as regular user: '$targetUser', profile path: '$userProfilePath'"
}

# Step 1: Check registry for OneDrive installation and run uninstaller if found
if ($targetUser) {
    $userSID = Get-UserSID -Username $targetUser
    if ($userSID) {
        Write-Output "User SID for '$targetUser': $userSID"

        # Check if OneDrive uninstall entry exists in user's registry
        $uninstallKey = "HKU\$userSID\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\OneDriveSetup.exe"
        Write-Output "Checking uninstall registry key: $uninstallKey"

        try {
            # Query the uninstall string
            $uninstallString = reg.exe query $uninstallKey /v UninstallString 2>$null
            if ($LASTEXITCODE -eq 0 -and $uninstallString) {
                # Extract the actual command from reg output
                $uninstallLine = $uninstallString | Where-Object { $_ -match "UninstallString" } | Select-Object -First 1
                if ($uninstallLine -match "REG_SZ\s+(.+)") {
                    $uninstallCommand = $matches[1].Trim()
                    Write-Output "Found uninstall command: $uninstallCommand"

                    # Stop OneDrive processes
                    Write-Output "Stopping OneDrive processes"
                    Stop-Process -Name "*OneDrive*" -Force -ErrorAction SilentlyContinue | Out-Null

                    # Execute the uninstall command directly
                    Write-Output "Executing registry-based uninstaller"

                    if ($uninstallCommand -match '^"([^"]+)"(.*)') {
                        $exePath = $matches[1]
                        $arguments = $matches[2].Trim()
                        Write-Output "Command: '$exePath' Arguments: '$arguments'"
                        Start-Process -FilePath $exePath -ArgumentList $arguments -WindowStyle Hidden -Wait | Out-Null
                    } else {
                        # Fallback: execute as-is
                        Write-Output "Command: '$uninstallCommand'"
                        cmd.exe /c $uninstallCommand 2>&1 | Out-Null
                    }
                    Write-Output "Registry-based uninstaller completed"
                } else {
                    Write-Output "Could not parse UninstallString from registry output"
                }
            } else {
                Write-Output "OneDrive uninstall registry key not found or empty"
            }
        }
        catch {
            Write-Output "Registry-based uninstall failed: $($_.Exception.Message)"
        }
    } else {
        Write-Output "Could not get user SID for '$targetUser'"
    }
} else {
    Write-Output "No target user found for uninstall check"
}

# Step 3: Always run cleanup tasks
Write-Output "Starting cleanup tasks"

# 3.1: Delete OneDrive registry key
if ($targetUser -and $userSID) {
    $uninstallKey = "HKU\$userSID\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\OneDriveSetup.exe"
    Write-Output "Deleting OneDrive uninstall registry key: $uninstallKey"
    reg.exe delete $uninstallKey /f 2>&1 | Out-Null
    if ($LASTEXITCODE -eq 0) {
        Write-Output "Registry key deleted successfully"
    } else {
        Write-Output "Registry key not found or already deleted"
    }
}

# 3.2: Delete OneDrive AppData folder
if ($userProfilePath) {
    $currentUserOneDrivePath = Join-Path $userProfilePath "AppData\Local\Microsoft\OneDrive"
    Write-Output "Checking OneDrive AppData folder: $currentUserOneDrivePath"

    if (Test-Path $currentUserOneDrivePath) {
        Write-Output "Removing OneDrive folder for user: $targetUser"
        try {
            takeown /f $currentUserOneDrivePath /r /d y 2>&1 | Out-Null
            icacls $currentUserOneDrivePath /grant "${env:USERNAME}:F" /t 2>&1 | Out-Null
            Remove-Item $currentUserOneDrivePath -Recurse -Force -ErrorAction SilentlyContinue
            Write-Output "OneDrive folder removed for user: $targetUser"
        }
        catch {
            Write-Output "Failed to remove OneDrive folder for user: $targetUser - $($_.Exception.Message)"
        }
    } else {
        Write-Output "OneDrive AppData folder not found"
    }
}

# 3.3: Delete OneDrive Start Menu entry
if ($userProfilePath) {
    $startMenuPath = Join-Path $userProfilePath "AppData\Roaming\Microsoft\Windows\Start Menu\Programs\OneDrive.lnk"
    Write-Output "Checking OneDrive Start Menu shortcut: $startMenuPath"

    if (Test-Path $startMenuPath) {
        Remove-Item $startMenuPath -Force -ErrorAction SilentlyContinue
        Write-Output "OneDrive Start Menu shortcut removed"
    } else {
        Write-Output "OneDrive Start Menu shortcut not found"
    }
}

# 3.4: Delete system OneDrive files
$systemPaths = @(
    "C:\Windows\System32\OneDriveSetup.exe",
    "C:\Windows\SysWOW64\OneDriveSetup.exe",
    "C:\Program Files\Microsoft OneDrive"
)

foreach ($path in $systemPaths) {
    Write-Output "Checking system path: $path"
    if (Test-Path $path) {
        Write-Output "Removing: $path"
        try {
            takeown /f $path /r /d y 2>&1 | Out-Null
            icacls $path /grant "${env:USERNAME}:F" /t 2>&1 | Out-Null
            Remove-Item $path -Recurse -Force -ErrorAction SilentlyContinue
            Write-Output "Successfully removed: $path"
        }
        catch {
            Write-Output "Failed to remove: $path - $($_.Exception.Message)"
        }
    } else {
        Write-Output "Path not found: $path"
    }
}

# 3.5: Delete OneDrive scheduled tasks
Write-Output "Checking for OneDrive scheduled tasks"
try {
    $oneDriveTasks = Get-ScheduledTask -TaskName "*OneDrive*" -ErrorAction SilentlyContinue
    if ($oneDriveTasks) {
        foreach ($task in $oneDriveTasks) {
            # Skip the OneDriveRemoval task
            if ($task.TaskName -eq "OneDriveRemoval") {
                Write-Output "Skipping OneDriveRemoval task: $($task.TaskName)"
                continue
            }
            
            Write-Output "Found OneDrive scheduled task: $($task.TaskName) - State: $($task.State)"
            try {
                Unregister-ScheduledTask -TaskName $task.TaskName -TaskPath $task.TaskPath -Confirm:$false -ErrorAction SilentlyContinue
                Write-Output "Deleted scheduled task: $($task.TaskName)"
            }
            catch {
                Write-Output "Failed to delete scheduled task: $($task.TaskName) - $($_.Exception.Message)"
            }
        }
    } else {
        Write-Output "No OneDrive scheduled tasks found"
    }
}
catch {
    Write-Output "Failed to check scheduled tasks: $($_.Exception.Message)"
}

# 3.6: Configure default user registry to prevent OneDrive auto-install
$markerKey = "HKLM\SOFTWARE\Winhance\OneDriveRemoval"
$markerValue = reg.exe query $markerKey /v "DefaultUserConfigured" 2>$null

if ($LASTEXITCODE -eq 0) {
    Write-Output "Default user already configured on this machine, skipping this step."
} else {
    Write-Output "Configuring registry to prevent OneDrive auto-install for new users"
    reg.exe Load HKEY_USERS\Default "C:\Users\Default\NTUSER.DAT" 2>&1 | Out-Null
    reg.exe delete "HKU\Default\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "OneDriveSetup" /f 2>&1 | Out-Null
    reg.exe add "HKU\Default\SOFTWARE\Microsoft\OneDrive" /v "EnableTHDFFeatures" /t REG_DWORD /d "0" /f 2>&1 | Out-Null
    # Close regedit in case it is running so we can unload the hive
    Stop-Process -Name "regedit" -Force -ErrorAction SilentlyContinue
    reg.exe Unload HKEY_USERS\Default 2>&1 | Out-Null

    # Create marker to indicate this machine has been configured
    reg.exe add $markerKey /v "DefaultUserConfigured" /t REG_SZ /d "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" /f 2>&1 | Out-Null
    Write-Output "Default user configuration completed and marked"
}

# 1. Create the Appx Deprovisioned Marker
$OneDrivePFN = "Microsoft.OneDrive_8wekyb3d8bbwe"
$DeprovisionPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore\Deprovisioned\$OneDrivePFN"
if (!(Test-Path $DeprovisionPath)) { New-Item -Path $DeprovisionPath -Force }

# 2. Block the legacy system-wide installer via Policy
# This is the "Gold Standard" for 2025 to stop the .exe from returning
$PolicyPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\OneDrive"
if (!(Test-Path $PolicyPath)) { New-Item -Path $PolicyPath -Force }
New-ItemProperty -Path $PolicyPath -Name "DisableFileSyncNGSC" -Value 1 -PropertyType DWORD -Force

Write-Output "Done."
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\RemoveEdge.ps1">
<![CDATA[

<#
  .SYNOPSIS
      Removes Microsoft Edge (Legacy and Chromium versions) from Windows 10/11 systems.

  .DESCRIPTION
      This script detects and removes Microsoft Edge installations including:
      - Legacy UWP Edge (pre-Chromium)
      - Chromium-based Edge (current version)
      - EdgeUpdate components
      - EdgeWebView2 is NOT removed

      This script is designed to run in any context: user sessions, SYSTEM account, or scheduled tasks.

  .NOTES
      Source: https://github.com/memstechtips/Winhance

      Requirements:
      - Windows 10/11
      - Administrator privileges (script will auto-elevate)
      - PowerShell 5.1 or higher

      Credits:
      - Legacy Edge removal based on work by ishad0w: https://gist.github.com/ishad0w/d25ca52eb04dbefba8087a344a69c79c
      - Chromium Edge removal based on work by FR33THY: https://github.com/FR33THYFR33THY/Ultimate-Windows-Optimization-Guide/blob/main/6%20Windows/14%20Edge.ps1
      - Edge protocol redirect based on OpenWebSearch by AveYo: https://github.com/AveYo/fox/blob/main/OpenWebSearch.cmd
      
      Minor refactoring for embedding in Schneegans's generated autounattend.xml
#>

# Check if script is running as Administrator
If (!([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]"Administrator")) {
    Try {
        Start-Process PowerShell.exe -ArgumentList ("-NoProfile -ExecutionPolicy Bypass -File `"{0}`"" -f $PSCommandPath) -Verb RunAs
        Exit
    }
    Catch {
        Write-Output "Failed to run as Administrator. Please rerun with elevated privileges."
        Exit
    }
}

# Helper function to get Legacy Edge packages
function Get-LegacyEdgePackages {
    $legacyRegPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\Packages"
    return Get-ChildItem -Path $legacyRegPath -Name -ErrorAction SilentlyContinue | Where-Object { $_ -match "Microsoft-Windows-Internet-Browser-Package" -and $_ -match "~~" }
}

# Function to test if Legacy Edge is installed
function Test-LegacyEdgeInstalled {
    $packages = Get-LegacyEdgePackages

    if ($packages) {
        foreach ($package in $packages) {
            $packageInfo = & dism /online /Get-PackageInfo /PackageName:$package 2>$null
            if ($packageInfo -match "State.*Installed") {
                return $true
            }
        }
    }
    return $false
}

# Function to test if Chromium Edge is installed
function Test-ChromiumEdgeInstalled {
    # Check folders first (fastest)
    $edgeFolders = @("Edge", "EdgeCore", "EdgeUpdate")
    $programFiles = @($env:ProgramFiles, ${env:ProgramFiles(x86)})

    foreach ($pf in $programFiles) {
        foreach ($folder in $edgeFolders) {
            if (Test-Path "$pf\Microsoft\$folder") {
                return $true
            }
        }
    }

    # Fallback: Check installed programs
    try {
        $edgeApp = Get-WmiObject -Class Win32_InstalledStoreProgram -Filter "Name like '%Microsoft.MicrosoftEdge.Stable%'" -ErrorAction SilentlyContinue
        return $edgeApp -ne $null
    } catch {
        return $false
    }
}

# Function to stop Edge-related processes
function Stop-EdgeProcesses {
    Write-Output "Stopping Edge-related processes and services"
    $stop = "MicrosoftEdgeUpdate", "OneDrive", "WidgetService", "Widgets", "msedge", "Resume", "CrossDeviceResume", "msedgewebview2"
    $stop | ForEach-Object {
        $processCount = (Get-Process -Name $_ -ErrorAction SilentlyContinue).Count
        if ($processCount -gt 0) {
            Stop-Process -Name $_ -Force -ErrorAction SilentlyContinue
            Write-Output "Stopped $processCount instance(s) of $_"
        }
    }
}

# Function to remove Legacy Edge
function Remove-LegacyEdge {
    Write-Output "Starting Legacy Edge/UWP Edge removal process"
    # Query registry for Edge Legacy package
    $packages = Get-LegacyEdgePackages
    $edgeLegacyPackageVersion = $packages | Select-Object -First 1
    $packagePath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\Packages\$edgeLegacyPackageVersion"
    # Set registry visibility
    Set-ItemProperty -Path $packagePath -Name "Visibility" -Value 1 -Type DWord -Force -ErrorAction SilentlyContinue
    # Remove owners registry entries
    $ownersPath = "$packagePath\Owners"
    if (Test-Path $ownersPath) { Remove-Item -Path $ownersPath -Recurse -Force -ErrorAction SilentlyContinue }
    Write-Output "Removing Legacy Edge package via DISM (with 30-second timeout)"
    $dismProcess = Start-Process -FilePath "dism.exe" -ArgumentList "/online", "/Remove-Package", "/PackageName:$edgeLegacyPackageVersion", "/NoRestart" -NoNewWindow -PassThru

    if ($dismProcess -and $dismProcess.WaitForExit(30000)) {
        Write-Output "DISM completed successfully"
    } elseif ($dismProcess) {
        Write-Output "DISM timed out after 30 seconds, killing process and retrying once"
        $dismProcess.Kill()
        Start-Sleep 2

        # Retry once
        Write-Output "Retrying DISM command"
        $retryProcess = Start-Process -FilePath "dism.exe" -ArgumentList "/online", "/Remove-Package", "/PackageName:$edgeLegacyPackageVersion", "/NoRestart" -NoNewWindow -PassThru

        if ($retryProcess -and $retryProcess.WaitForExit(30000)) {
            Write-Output "DISM retry completed successfully"
        } elseif ($retryProcess) {
            Write-Output "DISM retry also timed out, continuing with script"
            $retryProcess.Kill()
        } else {
            Write-Output "DISM retry failed to start, continuing with script"
        }
    } else {
        Write-Output "DISM failed to start, continuing with script"
    }
    # Remove Legacy UWP Edge package
    Write-Output "Removing Legacy UWP Edge package"
    Get-AppxPackage Microsoft.MicrosoftEdge | Remove-AppxPackage -ErrorAction SilentlyContinue | Out-Null
    Write-Output "Legacy Edge/UWP Edge removal process completed"
}

# Function to remove Edge shortcuts
function Remove-EdgeShortcuts {
    Write-Output "Starting Edge shortcuts cleanup"

    # Get ALL user profiles (no exclusions)
    $userProfiles = Get-ChildItem -Path "C:\Users" -Directory | Where-Object {
        (Test-Path -Path "$($_.FullName)\NTUSER.DAT")
    }

    # Build all shortcut paths to check
    $shortcutPaths = @()

    # Add user-specific paths (now includes Public, Default, etc.)
    foreach ($profile in $userProfiles) {
        $shortcutPaths += @(
            "$($profile.FullName)\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\Microsoft Edge.lnk",
            "$($profile.FullName)\Desktop\Microsoft Edge.lnk",
            "$($profile.FullName)\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\Microsoft Edge.lnk",
            "$($profile.FullName)\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\Tombstones\Microsoft Edge.lnk",
            "$($profile.FullName)\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Microsoft Edge.lnk"
        )
    }

    # Add the single ProgramData path
    $shortcutPaths += "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Microsoft Edge.lnk"

    # Remove all shortcuts in one loop
    $removedCount = 0
    foreach ($path in $shortcutPaths) {
        if (Test-Path -Path $path -PathType Leaf) {
            Remove-Item -Path $path -Force -ErrorAction SilentlyContinue
            $removedCount++
        }
    }

    Write-Output "Removed $removedCount Edge shortcut(s)"
}

function Install-EdgeProtocolRedirect {
    Write-Output "Checking if Edge protocol redirect is needed"

    $ifeoCheck = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ie_to_edge_stub.exe\0"
    if (Test-Path $ifeoCheck) {
        $debugger = (Get-ItemProperty -Path $ifeoCheck -Name "Debugger" -ErrorAction SilentlyContinue).Debugger
        if ($debugger -like "*OpenWebSearch*") {
            Write-Output "Edge protocol redirect already installed"
            return
        }
    }

    Write-Output "Installing Edge protocol redirect using OpenWebSearch"
    $scriptsDir = "C:\MySetup\Scripts\OpenWebSearch"
    New-Item -ItemType Directory -Path $scriptsDir -Force -ErrorAction SilentlyContinue | Out-Null

    $stubTargetPath = "$scriptsDir\ie_to_edge_stub.exe"
    if (!(Test-Path $stubTargetPath)) {
        Write-Output "Warning: ie_to_edge_stub.exe not found at $stubTargetPath (should have been copied before Edge removal)"
        return
    }

    $openWebSearchContent = @"
@title OpenWebSearch 2023 & echo off
for /f %%E in ('"prompt `$E`$S& for %%e in (1) do rem"') do echo;%%E[2t 2>nul

call :reg_var "HKCU\SOFTWARE\Microsoft\Windows\Shell\Associations\UrlAssociations\https\UserChoice" ProgID ProgID
if /i "%ProgID%" equ "MSEdgeHTM" exit /b

call :reg_var "HKCR\%ProgID%\shell\open\command" "" Browser
set Choice=& for %%. in (%Browser%) do if not defined Choice set "Choice=%%~."

call :reg_var "HKCR\MSEdgeMHT\shell\open\command" "" FallBack
set "Edge=" & for %%. in (%FallBack%) do if not defined Edge set "Edge=%%~."
set "URI=" & set "URL=" & set "NOOP=" & set "PassTrough=%Edge:msedge=edge%"

set "CLI=%CMDCMDLINE:"=````%"
if defined CLI set "CLI=%CLI:*ie_to_edge_stub.exe```` =%"
if defined CLI set "CLI=%CLI:*ie_to_edge_stub.exe =%"
if defined CLI set "CLI=%CLI:*msedge.exe```` =%"
if defined CLI set "CLI=%CLI:*msedge.exe =%"
set "FIX=%CLI:~-1%"
if defined CLI if "%FIX%"==" " set "CLI=%CLI:~0,-1%"
if defined CLI set "RED=%CLI:microsoft-edge=%"
if defined CLI set "URL=%CLI:http=%"
if defined CLI set "ARG=%CLI:````="%"

if "%CLI%" equ "%RED%" (set NOOP=1) else if "%CLI%" equ "%URL%" (set NOOP=1)
if defined NOOP if not exist "%PassTrough%" echo;@mklink /h "%PassTrough%" "%Edge%" >"%Temp%\OpenWebSearchRepair.cmd"
if defined NOOP if not exist "%PassTrough%" schtasks /run /tn OpenWebSearchRepair 2>nul >nul
if defined NOOP if not exist "%PassTrough%" timeout /t 3 >nul
if defined NOOP if exist "%PassTrough%" start "" "%PassTrough%" %ARG%
if defined NOOP exit /b

set "URL=%CLI:*microsoft-edge=%"
set "URL=http%URL:*http=%"
set "FIX=%URL:~-2%"
if defined URL if "%FIX%"=="````" set "URL=%URL:~0,-2%"
call :dec_url
start "" "%Choice%" "%URL%"
exit

:reg_var
set {var}=& set {reg}=reg query "%~1" /v %2 /z /se "," /f /e& if %2=="" set {reg}=reg query "%~1" /ve /z /se "," /f /e
for /f "skip=2 tokens=* delims=" %%V in ('%{reg}% %4 %5 %6 %7 %8 %9 2^>nul') do if not defined {var} set "{var}=%%V"
if not defined {var} (set {reg}=& set "%~3="& exit /b) else if %2=="" set "{var}=%{var}:*)    =%"
if not defined {var} (set {reg}=& set "%~3="& exit /b) else set {reg}=& set "%~3=%{var}:*)    =%"& set {var}=& exit /b

:dec_url
set ".=%URL:!=}%" & setlocal enabledelayedexpansion
set ".=!.:%%={!" &set ".=!.:{3A=:!" &set ".=!.:{2F=/!" &set ".=!.:{3F=?!" &set ".=!.:{23=#!" &set ".=!.:{5B=[!" &set ".=!.:{5D=]!"
set ".=!.:{40=@!"&set ".=!.:{21=}!" &set ".=!.:{24=`$!" &set ".=!.:{26=&!" &set ".=!.:{27='!" &set ".=!.:{28=(!" &set ".=!.:{29=)!"
set ".=!.:{2A=*!"&set ".=!.:{2B=+!" &set ".=!.:{2C=,!" &set ".=!.:{3B=;!" &set ".=!.:{3D==!" &set ".=!.:{25=%%!"&set ".=!.:{20= !"
set ".=!.:{=%%!" & endlocal& set "URL=%.:}=!%" & exit /b
"@

    $openWebSearchPath = "$scriptsDir\OpenWebSearch.cmd"
    $openWebSearchContent | Out-File -FilePath $openWebSearchPath -Encoding ASCII -Force
    Write-Output "Created OpenWebSearch.cmd at $openWebSearchPath"

    $msedgePath = "${env:ProgramFiles(x86)}\Microsoft\Edge\Application\msedge.exe"
    $edgePath = "${env:ProgramFiles(x86)}\Microsoft\Edge\Application\edge.exe"
    if ((Test-Path $msedgePath) -and !(Test-Path $edgePath)) {
        cmd /c mklink /h "$edgePath" "$msedgePath" 2>&1 | Out-Null
        Write-Output "Created edge.exe hardlink at $edgePath"
    }

    $buildNumber = [Environment]::OSVersion.Version.Build
    $conhostFlags = if ($buildNumber -gt 25179) { "--width 1 --height 1" } else { "--headless" }
    $conhostDebugger = "$env:SystemRoot\system32\conhost.exe $conhostFlags $scriptsDir\OpenWebSearch.cmd"

    Write-Output "Configuring registry entries for Edge protocol redirect"
    reg.exe add "HKCR\microsoft-edge" /f /ve /d "URL:microsoft-edge" 2>&1 | Out-Null
    reg.exe add "HKCR\microsoft-edge" /f /v "URL Protocol" /d `"`" 2>&1 | Out-Null
    reg.exe add "HKCR\microsoft-edge" /f /v "NoOpenWith" /d `"`" 2>&1 | Out-Null
    reg.exe add "HKCR\microsoft-edge\shell\open\command" /f /ve /d "$stubTargetPath %1" 2>&1 | Out-Null
    reg.exe add "HKCR\MSEdgeHTM" /f /v "NoOpenWith" /d `"`" 2>&1 | Out-Null
    reg.exe add "HKCR\MSEdgeHTM\shell\open\command" /f /ve /d "$stubTargetPath %1" 2>&1 | Out-Null
    reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ie_to_edge_stub.exe" /f /v UseFilter /d 1 /t reg_dword 2>&1 | Out-Null
    reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ie_to_edge_stub.exe\0" /f /v FilterFullPath /d "$stubTargetPath" 2>&1 | Out-Null
    reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ie_to_edge_stub.exe\0" /f /v Debugger /d "$conhostDebugger" 2>&1 | Out-Null
    reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\msedge.exe" /f /v UseFilter /d 1 /t reg_dword 2>&1 | Out-Null
    reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\msedge.exe\0" /f /v FilterFullPath /d "$msedgePath" 2>&1 | Out-Null
    reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\msedge.exe\0" /f /v Debugger /d "$conhostDebugger" 2>&1 | Out-Null
    Write-Output "Registry configuration completed"

    $repairScriptPath = "$scriptsDir\OpenWebSearchRepair.cmd"
    $repairScriptContent = "@echo off`r`nmklink /h ""$edgePath"" ""$msedgePath"""
    $repairScriptContent | Out-File -FilePath $repairScriptPath -Encoding ASCII -Force
    Write-Output "Created repair script at $repairScriptPath"

    Write-Output "Creating OpenWebSearchRepair scheduled task"
    try {
        $taskAction = New-ScheduledTaskAction -Execute $repairScriptPath
        $taskTrigger = New-ScheduledTaskTrigger -Once -At (Get-Date).Date
        $taskSettings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
        $taskPrincipal = New-ScheduledTaskPrincipal -UserId "S-1-5-18" -LogonType ServiceAccount -RunLevel Highest
        Register-ScheduledTask -TaskName 'OpenWebSearchRepair' -Action $taskAction -Trigger $taskTrigger -Settings $taskSettings -Principal $taskPrincipal -Force | Out-Null
        Write-Output "OpenWebSearchRepair scheduled task created"
    } catch {
        Write-Output "Failed to create OpenWebSearchRepair scheduled task: $($_.Exception.Message)"
    }
}

# Function to remove Chromium Edge and EdgeUpdate
function Remove-ChromiumEdge {
    # Remove Chromium Edge
    Write-Output "Starting Edge Chromium uninstallation process"
    # Folder and file to allow uninstall of Edge Chromium Browser
    Write-Output "Creating temporary directory for Edge uninstallation"
    $edgePath = "$env:SystemRoot\SystemApps\Microsoft.MicrosoftEdge_8wekyb3d8bbwe"
    New-Item -Path $edgePath -ItemType Directory -ErrorAction SilentlyContinue | Out-Null
    New-Item -Path $edgePath -ItemType File -Name "MicrosoftEdge.exe" -ErrorAction SilentlyContinue | Out-Null
    # Get Edge Uninstall Strings for Enterprise MSI version or normal version (they require different handling)
    Write-Output "Searching for Edge uninstall strings in registry"
    $uninstallKeys = Get-ChildItem "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
    $edgeUninstallCount = 0
    foreach ($key in $uninstallKeys) {
        $displayName = (Get-ItemProperty $key.PSPath -ErrorAction SilentlyContinue).DisplayName
        if ($displayName -like "*Microsoft Edge*") {
            $uninstallString = (Get-ItemProperty $key.PSPath).UninstallString
            if ($uninstallString) {
                $edgeUninstallCount++
                if ($uninstallString -like "*msiexec*") {
                    # Uninstalls Enterprise MSI version
                    Write-Output "Executing MSI uninstaller for Edge"
                    Start-Process cmd.exe "/c $uninstallString /quiet" -WindowStyle Hidden -Wait | Out-Null
                } else {
                    # Uninstalls normal version
                    Write-Output "Executing standard uninstaller for Edge"
                    Start-Process cmd.exe "/c $uninstallString --force-uninstall --silent" -WindowStyle Hidden -Wait | Out-Null
                }
            }
        }
    }
    if ($edgeUninstallCount -eq 0) {
        Write-Output "No Edge uninstall entries found in registry"
    } else {
        Write-Output "Executed $edgeUninstallCount Edge uninstaller(s)"
    }
    # Remove UWP Edge Chromium package
    Write-Output "Removing UWP Edge Chromium package"
    Get-AppxPackage *Microsoft.MicrosoftEdge.Stable* | Remove-AppxPackage -ErrorAction SilentlyContinue | Out-Null
    # Cleanup: Remove folder and file we created earlier
    Write-Output "Cleaning up temporary Edge directory"
    Remove-Item -Recurse -Force $edgePath -ErrorAction SilentlyContinue | Out-Null
    Write-Output "Edge Chromium uninstallation process completed"

    # Remove EdgeUpdate
    Write-Output "Starting EdgeUpdate removal process"
    # Find EdgeUpdate executables
    Write-Output "Searching for EdgeUpdate executables"
    $edgeupdate = @()
    $searchPaths = @("LocalApplicationData", "ProgramFilesX86", "ProgramFiles")
    foreach ($pathType in $searchPaths) {
        $folder = [Environment]::GetFolderPath($pathType)
        $searchPattern = "$folder\Microsoft\EdgeUpdate\*.*.*.*\MicrosoftEdgeUpdate.exe"
        $foundFiles = Get-ChildItem $searchPattern -Recurse -ErrorAction SilentlyContinue
        if ($foundFiles) {
            $edgeupdate += $foundFiles.FullName
        }
    }
    if ($edgeupdate.Count -gt 0) {
        Write-Output "Found $($edgeupdate.Count) EdgeUpdate executable(s)"
    } else {
        Write-Output "No EdgeUpdate executables found"
    }
    # Backup ClientState registry if it exists (important, or else webview won't work)
    $backupRegFile = "$env:TEMP\EdgeUpdate_ClientState_Backup_$(Get-Date -Format 'yyyyMMdd_HHmmss').reg"
    $clientStatePath = "HKLM:\SOFTWARE\WOW6432Node\Microsoft\EdgeUpdate\ClientState"
    if (Test-Path $clientStatePath) {
        Write-Output "Backing up EdgeUpdate ClientState registry"
        cmd /c "reg export `"HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\EdgeUpdate\ClientState`" `"$backupRegFile`" /y" 2>$null
        if (Test-Path $backupRegFile) {
            Write-Output "Successfully created registry backup at $backupRegFile"
        } else {
            Write-Output "Warning: Failed to create registry backup"
        }
    } else {
        Write-Output "No EdgeUpdate ClientState registry found to backup"
    }
    # Clean registry entries
    Write-Output "Removing EdgeUpdate registry entries"
    $registryPaths = @(
        "HKLM:\SOFTWARE", "HKLM:\SOFTWARE\Policies", "HKLM:\SOFTWARE\WOW6432Node", "HKLM:\SOFTWARE\WOW6432Node\Policies"
    )
    $removedRegCount = 0
    foreach ($location in $registryPaths) {
        $regPath = "$location\Microsoft\EdgeUpdate"
        if (Test-Path $regPath) {
            Remove-Item $regPath -Recurse -Force -ErrorAction SilentlyContinue
            $removedRegCount++
        }
    }
    Write-Output "Removed EdgeUpdate registry entries from $removedRegCount location(s)"
    # Uninstall EdgeUpdate executables
    Write-Output "Processing EdgeUpdate uninstallation"
    foreach ($path in $edgeupdate) {
        if (Test-Path $path) {
            # Unregister service
            Write-Output "Unregistering EdgeUpdate service from $path"
            Start-Process -FilePath $path -ArgumentList "/unregsvc" -Wait -WindowStyle Hidden -ErrorAction SilentlyContinue
            # Wait for processes to finish
            $waitCount = 0
            do {
                Start-Sleep 3
                $runningProcesses = Get-Process -Name "setup", "MicrosoftEdge*" -ErrorAction SilentlyContinue | Where-Object { $_.Path -like "*\Microsoft\Edge*" }
            } while ($runningProcesses -and $waitCount++ -lt 20)
            # Run uninstall if file still exists
            if (Test-Path $path) {
                Write-Output "Running EdgeUpdate uninstaller from $path"
                Start-Process -FilePath $path -ArgumentList "/uninstall" -Wait -WindowStyle Hidden -ErrorAction SilentlyContinue
            }
        }
    }
    # Restore ClientState backup
    if ((Test-Path $backupRegFile)) {
        Write-Output "Restoring EdgeUpdate ClientState registry from backup"
        cmd /c "reg import `"$backupRegFile`"" 2>$null
        Remove-Item $backupRegFile -ErrorAction SilentlyContinue
        Write-Output "Registry restore completed and backup file cleaned up"
    } else {
        Write-Output "No registry backup file found to restore"
    }
    Write-Output "EdgeUpdate removal process completed"
}

Write-Output "Starting Edge removal process. See $logFile for details."

# Check for Edge installations first
Write-Output "Checking for Edge installations..."

$legacyInstalled = Test-LegacyEdgeInstalled
$chromiumInstalled = Test-ChromiumEdgeInstalled

if (-not $legacyInstalled -and -not $chromiumInstalled) {
    Write-Output "No Edge installations detected. Exiting."
    Write-Output "No Edge installations found. Script exiting."
    exit 0
}

$removedSomething = $false
$stubPath = $null

if ($chromiumInstalled) {
    Write-Output "Chromium Edge detected. Finding ie_to_edge_stub.exe before removal."

    $stubLocations = @("$env:ProgramData\ie_to_edge_stub.exe", "$env:Public\ie_to_edge_stub.exe")
    foreach ($loc in $stubLocations) {
        if (Test-Path $loc) {
            $stubPath = $loc
            Write-Output "Found stub at: $loc"
            break
        }
    }

    if (!$stubPath) {
        $stubSearch = Get-ChildItem "${env:ProgramFiles(x86)}\Microsoft\Edge" -Filter "ie_to_edge_stub.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
        if ($stubSearch) {
            $stubPath = $stubSearch.FullName
            Write-Output "Found stub at: $stubPath"
        } else {
            Write-Output "ie_to_edge_stub.exe not found in any location"
        }
    }

    if ($stubPath) {
        $scriptsDir = "C:\MySetup\Scripts\OpenWebSearch"
        New-Item -ItemType Directory -Path $scriptsDir -Force -ErrorAction SilentlyContinue | Out-Null
        Copy-Item $stubPath "$scriptsDir\ie_to_edge_stub.exe" -Force -ErrorAction SilentlyContinue
        Write-Output "Copied ie_to_edge_stub.exe to $scriptsDir before Edge removal"
    }
}

if ($legacyInstalled) {
    Write-Output "Legacy Edge detected. Proceeding with removal."
    Stop-EdgeProcesses
    Remove-LegacyEdge
    $removedSomething = $true
}

if ($chromiumInstalled) {
    Write-Output "Chromium Edge detected. Proceeding with removal."
    Stop-EdgeProcesses
    Remove-ChromiumEdge
    $removedSomething = $true
}

# Only do cleanup if we removed something
if ($removedSomething) {
    # Cleanup: Remove folders containing Edge (Edge, EdgeCore, EdgeUpdate) or Temp but exclude EdgeWebView
    Write-Output "Starting cleanup of Microsoft Edge folders"
    $edgeFolders = Get-ChildItem -Path "$env:SystemDrive\Program Files (x86)\Microsoft" -Directory -ErrorAction SilentlyContinue |
    Where-Object { ($_.Name -like "*Edge*" -or $_.Name -like "*Temp*") -and $_.Name -notlike "*EdgeWebView*" }
    if ($edgeFolders) {
        Write-Output "Found $($edgeFolders.Count) Edge-related folder(s) to remove"
        $edgeFolders | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Write-Output "Cleanup of Microsoft Edge folders completed"
    } else {
        Write-Output "No Edge-related folders found to clean up"
    }

    Remove-EdgeShortcuts
    Install-EdgeProtocolRedirect
}

# Always check for and delete Edge scheduled tasks
Write-Output "Checking for Edge scheduled tasks"
try {
    $edgeTasks = Get-ScheduledTask -TaskName "*Edge*" -ErrorAction SilentlyContinue
    if ($edgeTasks) {
        foreach ($task in $edgeTasks) {
            # Skip the EdgeRemoval task
            if ($task.TaskName -eq "EdgeRemoval") {
                Write-Output "Skipping EdgeRemoval task: $($task.TaskName)"
                continue
            }
            
            Write-Output "Found Edge scheduled task: $($task.TaskName) - State: $($task.State)"
            try {
                Unregister-ScheduledTask -TaskName $task.TaskName -TaskPath $task.TaskPath -Confirm:$false -ErrorAction SilentlyContinue
                Write-Output "Deleted scheduled task: $($task.TaskName)"
            }
            catch {
                Write-Output "Failed to delete scheduled task: $($task.TaskName) - $($_.Exception.Message)"
            }
        }
    } else {
        Write-Output "No Edge scheduled tasks found"
    }
}
catch {
    Write-Output "Failed to check scheduled tasks: $($_.Exception.Message)"
}

Write-Output "Create the EdgeUpdate key and block automatic Chromium Edge installation"
$RegPath = "HKLM:\SOFTWARE\Microsoft\EdgeUpdate"
if (!(Test-Path $RegPath)) { New-Item -Path $RegPath -Force }
New-ItemProperty -Path $RegPath -Name "DoNotUpdateToEdgeWithChromium" -Value 1 -PropertyType DWORD -Force

Write-Output "Prevent Edge installation via standard Update policies"
$PolicyPath = "HKLM:\SOFTWARE\Policies\Microsoft\EdgeUpdate"
if (!(Test-Path $PolicyPath)) { New-Item -Path $PolicyPath -Force }
New-ItemProperty -Path $PolicyPath -Name "InstallDefault" -Value 0 -PropertyType DWORD -Force
New-ItemProperty -Path $PolicyPath -Name "Install{56EB18F8-8008-4CBD-B6D0-588447950844}" -Value 0 -PropertyType DWORD -Force

Write-Output "Put Package Family Names (PFN) for both Chromium and Legacy Edge in provisioned list"
$EdgePFNs = @(
    "Microsoft.MicrosoftEdge.Stable_8wekyb3d8bbwe", # Modern Chromium Edge
    "Microsoft.MicrosoftEdge_8wekyb3d8bbwe"         # Legacy Edge
)

foreach ($PFN in $EdgePFNs) {
    $Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore\Deprovisioned\$PFN"
    if (!(Test-Path $Path)) {
        New-Item -Path $Path -Force | Out-Null
        Write-Output "Deprovisioned marker added for: $PFN"
    }
}

Write-Output "Done."
]]>
		</File>
        <File path="C:\Windows\Setup\Scripts\ConfigurePowerSettings.System.ps1">
        
<![CDATA[
. "C:\MySetup\Scripts\Apply-Registry.ps1"

Write-Output "Setting up power plan: High Performance Laptop Plan..."

$customPlanGuid = "57696e68-616e-6365-506f-776572000000"

$existingPlan = powercfg /query $customPlanGuid 2>&1
$planExists = $LASTEXITCODE -eq 0

if ($planExists) {
    Write-Output "Power plan already exists, using existing plan"
} else {
    Write-Output "Creating new power plan..."
    $planCreated = $false

    $sourceSchemes = @(
        @{ Name = "Ultimate Performance"; Guid = "e9a42b02-d5df-448d-aa00-03f14749eb61" },
        @{ Name = "High Performance"; Guid = "8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c" },
        @{ Name = "Balanced"; Guid = "381b4222-f694-41f0-9685-ff5bb260df2e" }
    )

    foreach ($scheme in $sourceSchemes) {
        Write-Output "Attempting to duplicate from $($scheme.Name)..."
        $result = powercfg /duplicatescheme $($scheme.Guid) $customPlanGuid 2>&1
        if ($LASTEXITCODE -eq 0) {
            Write-Output "Successfully created from $($scheme.Name)"
            powercfg /changename $customPlanGuid "High Performance Laptop Plan" | Out-Null
            $planCreated = $true
            break
        }
    }

    if (-not $planCreated) {
        Write-Output "Failed to create power plan"
    }
}

Write-Output "Disabling hibernation..."
powercfg /hibernate on 2>$null
Write-Output "Hibernation enabled"

Write-Output "Enabling hidden power settings..."
$PowerSettingsBasePath = "HKLM:\SYSTEM\CurrentControlSet\Control\Power\PowerSettings"
$hiddenSettings = @(
    @{ Subgroup = "2a737441-1930-4402-8d77-b2bebba308a3"; Setting = "0853a681-27c8-4100-a2fd-82013e970683" },
    @{ Subgroup = "2a737441-1930-4402-8d77-b2bebba308a3"; Setting = "d4e98f31-5ffe-4ce1-be31-1b38b384c009" },
    @{ Subgroup = "4f971e89-eebd-4455-a8de-9e59040e7347"; Setting = "7648efa3-dd9c-4e3e-b566-50f929386280" },
    @{ Subgroup = "4f971e89-eebd-4455-a8de-9e59040e7347"; Setting = "96996bc0-ad50-47ec-923b-6f41874dd9eb" },
    @{ Subgroup = "4f971e89-eebd-4455-a8de-9e59040e7347"; Setting = "5ca83367-6e45-459f-a27b-476b1d01c936" },
    @{ Subgroup = "54533251-82be-4824-96c1-47b60b740d00"; Setting = "94d3a615-a899-4ac5-ae2b-e4d8f634367f" },
    @{ Subgroup = "54533251-82be-4824-96c1-47b60b740d00"; Setting = "be337238-0d82-4146-a960-4f3749d470c7" },
    @{ Subgroup = "54533251-82be-4824-96c1-47b60b740d00"; Setting = "465e1f50-b610-473a-ab58-00d1077dc418" },
    @{ Subgroup = "54533251-82be-4824-96c1-47b60b740d00"; Setting = "40fbefc7-2e9d-4d25-a185-0cfd8574bac6" },
    @{ Subgroup = "54533251-82be-4824-96c1-47b60b740d00"; Setting = "0cc5b647-c1df-4637-891a-dec35c318583" },
    @{ Subgroup = "54533251-82be-4824-96c1-47b60b740d00"; Setting = "ea062031-0e34-4ff1-9b6d-eb1059334028" },
    @{ Subgroup = "54533251-82be-4824-96c1-47b60b740d00"; Setting = "36687f9e-e3a5-4dbf-b1dc-15eb381c6863" },
    @{ Subgroup = "54533251-82be-4824-96c1-47b60b740d00"; Setting = "06cadf0e-64ed-448a-8927-ce7bf90eb35d" },
    @{ Subgroup = "54533251-82be-4824-96c1-47b60b740d00"; Setting = "12a0ab44-fe28-4fa9-b3bd-4b64f44960a6" }
)

foreach ($item in $hiddenSettings) {
    $regPath = Join-Path $PowerSettingsBasePath "$($item.Subgroup)\$($item.Setting)"
    Apply-RegistryEntry -Path $regPath -Name "Attributes" -Type "DWord" -Value 0
}

Write-Output "Applying power settings..."

$settings = @(

    <#
    #===============================================================================
    # Turn off display after
    #
    # Description:
    #   Controls how long the system waits before turning off the display due to
    #   inactivity. A longer timeout improves comfort and prevents interruptions,
    #   while a shorter timeout reduces power consumption and prevents burnin on
    #   OLED/IPS panels. This setting affects only the display, not system sleep.
    #
    # Options:
    #   Continuous range: 086400 seconds (0 = never turn off)
    #
    # Recommended:
    #   AC = 600  Provides a comfortable 10minute window without wasting energy.
    #   DC = 180  Saves significant battery life while still being userfriendly.
    #===============================================================================
    #>
    @{ S="7516b95f-f776-4464-8c53-06167f40cc99"; G="3c0bc021-c8a8-4e07-a973-6b14cbcb2b7e"; AC=600; DC=180 },

    <#
    #===============================================================================
    # Turn off hard disk after
    #
    # Description:
    #   Determines how long the system waits before spinning down mechanical hard
    #   drives. SSDs ignore this setting entirely, but HDDs benefit from reduced
    #   power usage when idle. Too short a timeout can cause frequent spinups,
    #   reducing drive lifespan and causing delays.
    #
    # Options:
    #   Continuous range: 086400 seconds (0 = never spin down)
    #
    # Recommended:
    #   AC = 0  Prevents unnecessary spindown delays and wear on HDDs.
    #   DC = 600  Saves battery on HDDbased systems without excessive cycling.
    #===============================================================================
    #>
    @{ S="0012ee47-9041-4b5d-9b77-535fba8b1442"; G="6738e2c4-e8a5-4a42-b16a-e040e769756e"; AC=0; DC=600 },

    <#
    #===============================================================================
    # JavaScript timer frequency
    #
    # Description:
    #   Controls how aggressively Windows coalesces JavaScript timers in browsers
    #   and UWP apps. Lower frequencies save power by batching timer events, while
    #   higher frequencies improve responsiveness and animation smoothness. This
    #   setting primarily affects web browsing and UI responsiveness.
    #
    # Options:
    #   0 = Maximum power savings (coalesced timers)
    #   1 = Maximum performance (highresolution timers)
    #
    # Recommended:
    #   AC = 1  Ensures smooth UI interactions and responsive web applications.
    #   DC = 0  Reduces background CPU wakeups and extends battery life.
    #===============================================================================
    #>
    @{ S="02f815b5-a5cf-4c84-bf20-649d1f75d3d8"; G="4c793e7d-a264-42e1-87d3-7a0d2f523ccd"; AC=1; DC=0 },

    <#
    #===============================================================================
    # Desktop background slideshow
    #
    # Description:
    #   Controls whether Windows rotates wallpaper images automatically. This setting
    #   uses inverted logic: 0 means slideshow is allowed, 1 means slideshow is
    #   paused. Allowing slideshows increases GPU wakeups and background activity,
    #   which can reduce battery life on portable devices.
    #
    # Options:
    #   0 = Slideshow available (NOT paused)
    #   1 = Slideshow paused
    #
    # Recommended:
    #   AC = 0  Cosmetic feature is fine on AC power with negligible impact.
    #   DC = 1  Prevents unnecessary GPU activity and saves battery.
    #===============================================================================
    #>
    @{ S="0d7dbae2-4294-402a-ba8e-26777e8488cd"; G="309dce9b-bef4-4119-9921-a851fb12f0f4"; AC=0; DC=0 },

    <#
    #===============================================================================
    # Wireless adapter power saving
    #
    # Description:
    #   Adjusts how aggressively the WiFi adapter reduces power usage. Higher power
    #   saving modes reduce throughput and increase latency, while performance mode
    #   keeps the radio fully active. This setting has a noticeable effect on both
    #   network responsiveness and battery life.
    #
    # Options:
    #   0 = Maximum performance
    #   1 = Low power saving
    #   2 = Medium power saving
    #   3 = Maximum power saving
    #
    # Recommended:
    #   AC = 0  Ensures maximum throughput and lowest latency for highperformance
    #            workloads such as streaming, gaming, and large file transfers.
    #   DC = 2  Provides a balanced compromise between battery life and stable,
    #            responsive WiFi performance.
    #===============================================================================
    #>
    @{ S="19cbb8fa-5279-450e-9fac-8a3d5fedd0c1"; G="12bbebe6-58d6-4636-95bb-3217ef867c1a"; AC=0; DC=2 },

    <#
    #===============================================================================
    # Sleep after
    #
    # Description:
    #   Determines how long the system remains idle before entering sleep mode.
    #   Sleep reduces power consumption significantly while allowing fast resume.
    #   On AC power, automatic sleep can interrupt long-running tasks, while on
    #   battery it prevents unnecessary drain during periods of inactivity.
    #
    # Options:
    #   Continuous range: 086400 seconds (0 = never sleep automatically)
    #
    # Recommended:
    #   AC = 0    Prevents the system from sleeping during workloads, updates,
    #              downloads, or long-running tasks where performance and uptime
    #              matter more than power savings.
    #   DC = 900  A 15minute timeout provides meaningful battery savings while
    #              still allowing the user to resume work quickly.
    #===============================================================================
    #>
    @{ S="238c9fa8-0aad-41ed-83f4-97be242c8f20"; G="29f6c1db-86da-48c5-9fdb-f2b67b1f44da"; AC=0; DC=900 },

    <#
    #===============================================================================
    # Allow wake timers
    #
    # Description:
    #   Controls whether scheduled tasks, maintenance operations, or Windows Update
    #   are allowed to wake the system from sleep. Allowing wake timers ensures
    #   important maintenance tasks occur on schedule, but can cause unexpected
    #   wake-upsespecially problematic on battery power.
    #
    # Options:
    #   0 = Disabled (no wake timers allowed)
    #   1 = Enabled (all wake timers allowed)
    #   2 = Important wake timers only (recommended default)
    #
    # Recommended:
    #   AC = 1    Allows critical system tasks (updates, maintenance) to run while
    #              preventing unnecessary wake-ups from nonessential tasks.
    #   DC = 0    Prevents the system from waking unexpectedly and draining the
    #              battery when the device is not in use.
    #===============================================================================
    #>
    @{ S="238c9fa8-0aad-41ed-83f4-97be242c8f20"; G="bd3b718a-0680-4d9d-8ab2-e1d2b4ac806d"; AC=2; DC=2 },

    <#
    #===============================================================================
    # Hibernate after
    #
    # Description:
    #   Specifies how long the system remains in sleep before transitioning to
    #   hibernate. Hibernate consumes almost no power and preserves the session
    #   even if the battery depletes. On AC power, hibernation is rarely needed,
    #   but on battery it prevents data loss during extended idle periods.
    #
    # Options:
    #   Continuous range: 086400 seconds (0 = never hibernate automatically)
    #
    # Recommended:
    #   AC = 0       Avoids unnecessary hibernation transitions that slow down
    #                 resume performance when AC power is available.
    #   DC = 10800   A 3hour timeout protects against battery drain during long
    #                 idle periods while still allowing convenient resume.
    #===============================================================================
    #>
    @{ S="238c9fa8-0aad-41ed-83f4-97be242c8f20"; G="9d7815a6-7ee4-497e-8888-515a05f02364"; AC=0; DC=10800 },

    <#
    #===============================================================================
    # Allow hybrid sleep
    #
    # Description:
    #   Hybrid sleep combines sleep and hibernate by saving memory contents to disk
    #   while also entering lowpower sleep. This protects against power loss while
    #   maintaining fast wake times. On AC power, the safety benefit is minimal,
    #   but on battery it provides protection if the battery depletes unexpectedly.
    #
    # Options:
    #   0 = Off
    #   1 = On
    #
    # Recommended:
    #   AC = 0    Disabling hybrid sleep improves sleep/wake speed and reduces
    #              unnecessary disk writes on systems with stable AC power.
    #   DC = 1    Enables data protection in case the battery drains completely
    #              while the system is sleeping.
    #===============================================================================
    #>
    @{ S="238c9fa8-0aad-41ed-83f4-97be242c8f20"; G="94ac6d29-73ce-41a6-809f-6363ba21b47e"; AC=0; DC=1 },

    <#
    #===============================================================================
    # USB idle timeout
    #
    # Description:
    #   Determines how long USB hubs and controllers wait before entering a lowpower
    #   idle state. Shorter timeouts save power but may cause issues with devices
    #   that do not handle aggressive power transitions well. Longer timeouts improve
    #   compatibility at the cost of slightly higher power usage.
    #
    # Options:
    #   Continuous timeout value (unit varies by hardware implementation)
    #
    # Recommended:
    #   AC = 50    Provides a reasonable delay that avoids unnecessary power
    #               transitions while maintaining compatibility with most devices.
    #   DC = 50    USB idle power savings are modest; using the same value avoids
    #               device instability while still allowing some power reduction.
    #===============================================================================
    #>
    @{ S="2a737441-1930-4402-8d77-b2bebba308a3"; G="0853a681-27c8-4100-a2fd-82013e970683"; AC=50; DC=50 },

    <#
    #===============================================================================
    # USB selective suspend
    #
    # Description:
    #   Controls whether Windows may suspend individual USB ports or devices when
    #   they are idle. This reduces power consumption by preventing unnecessary
    #   device polling. Most modern USB devices handle selective suspend correctly,
    #   but some older peripherals may behave unpredictably if aggressively powered
    #   down. Keeping this enabled generally provides meaningful power savings with
    #   minimal compatibility issues.
    #
    # Options:
    #   0 = Disabled
    #   1 = Enabled
    #
    # Recommended:
    #   AC = 1  Safe for nearly all devices and avoids wasting power on idle USB
    #            peripherals without affecting performance.
    #   DC = 1  Helps extend battery life by reducing background USB activity while
    #            maintaining compatibility with modern hardware.
    #===============================================================================
    #>
    @{ S="2a737441-1930-4402-8d77-b2bebba308a3"; G="48e6b7a6-50f5-4782-a5d4-53bb8f07e226"; AC=1; DC=1 },

    <#
    #===============================================================================
    # USB 3 linkstate power management
    #
    # Description:
    #   Determines how aggressively USB 3.0 ports enter lowpower link states when
    #   idle. Higher powersaving modes reduce energy usage but may introduce slight
    #   latency when waking devices. Most USB 3 devices tolerate these transitions
    #   well, but extremely aggressive settings can cause intermittent disconnects
    #   on poorly designed hardware.
    #
    # Options:
    #   0 = Off
    #   1 = Moderate power savings
    #   2 = Maximum power savings
    #
    # Recommended:
    #   AC = 1  Provides a balanced approach that avoids unnecessary latency while
    #            still reducing some idle power consumption.
    #   DC = 2  Maximizes battery savings by allowing deeper linkstate power
    #            reductions during idle periods.
    #===============================================================================
    #>
    @{ S="2a737441-1930-4402-8d77-b2bebba308a3"; G="d4e98f31-5ffe-4ce1-be31-1b38b384c009"; AC=1; DC=2 },

    <#
    #===============================================================================
    # Intel integrated graphics power plan
    #
    # Description:
    #   Adjusts the power/performance behavior of Intel integrated graphics. Higher
    #   performance modes improve rendering speed and responsiveness, while lower
    #   modes reduce GPU frequency and voltage to save power. This setting affects
    #   video playback, UI smoothness, and GPUaccelerated workloads.
    #
    # Options (typical Intel mapping):
    #   0 = Maximum battery life
    #   1 = Balanced
    #   2 = Maximum performance
    #
    # Recommended:
    #   AC = 2  Ensures the GPU runs at full capability for smooth UI performance,
    #            video playback, and GPUaccelerated tasks.
    #   DC = 1  Balanced mode reduces power usage while maintaining acceptable
    #            responsiveness for everyday tasks.
    #===============================================================================
    #>
    @{ S="44f3beca-a7c0-460e-9df2-bb8b99e0cba6"; G="3619c3f2-afb2-4afc-b0e9-e7fef372de36"; AC=2; DC=1 },

    <#
    #===============================================================================
    # Power button action
    #
    # Description:
    #   Defines what happens when the physical power button is pressed. Choosing
    #   sleep provides a fast, convenient way to pause work without shutting down.
    #   More drastic actions like shutdown or hibernate are typically unnecessary
    #   for a highperformance configuration unless specifically required.
    #
    # Options:
    #   0 = Do nothing
    #   1 = Sleep
    #   2 = Hibernate
    #   3 = Shut down
    #
    # Recommended:
    #   AC = 1  Sleep offers the best balance of convenience and speed, allowing
    #            quick resume without interrupting workflows.
    #   DC = 1  Consistent behavior across power states avoids confusion and still
    #            conserves battery effectively.
    #===============================================================================
    #>
    @{ S="4f971e89-eebd-4455-a8de-9e59040e7347"; G="7648efa3-dd9c-4e3e-b566-50f929386280"; AC=1; DC=1 },

    <#
    #===============================================================================
    # Sleep button action
    #
    # Description:
    #   Determines the action taken when the dedicated sleep button (if present) is
    #   pressed. Sleep is the most intuitive and least disruptive behavior for this
    #   button, providing quick suspend/resume without data loss or long delays.
    #
    # Options:
    #   0 = Do nothing
    #   1 = Sleep
    #   2 = Hibernate
    #   3 = Shut down
    #
    # Recommended:
    #   AC = 1  Ensures the sleep button behaves consistently with user expectations
    #            and provides fast suspend/resume functionality.
    #   DC = 1  Maintains consistent behavior and conserves battery effectively
    #            without forcing full hibernation.
    #===============================================================================
    #>
    @{ S="4f971e89-eebd-4455-a8de-9e59040e7347"; G="96996bc0-ad50-47ec-923b-6f41874dd9eb"; AC=1; DC=1 },

    <#
    #===============================================================================
    # Lid close action
    #
    # Description:
    #   Determines what happens when the laptop lid is closed. This is one of the
    #   most important mobilityrelated settings. Closing the lid is a natural and
    #   frequent action, so the behavior must be predictable. Sleep is the most
    #   intuitive and least disruptive choice, preserving the session while reducing
    #   power usage. More drastic actions (shutdown/hibernate) can interrupt work or
    #   cause delays. "Do nothing" is risky because the system may overheat in a bag.
    #
    # Options:
    #   0 = Do nothing
    #   1 = Sleep
    #   2 = Hibernate
    #   3 = Shut down
    #
    # Recommended:
    #   AC = 1  Sleep provides fast resume and avoids accidental shutdowns while
    #            still reducing power usage when the lid is closed.
    #   DC = 1  Ensures consistent behavior and prevents overheating in bags while
    #            still conserving battery effectively.
    #===============================================================================
    #>
    @{ S="4f971e89-eebd-4455-a8de-9e59040e7347"; G="5ca83367-6e45-459f-a27b-476b1d01c936"; AC=1; DC=1 },

    <#
    #===============================================================================
    # PCI Express ASPM (Active State Power Management)
    #
    # Description:
    #   Controls how aggressively PCI Express devices enter lowpower link states.
    #   Higher powersaving modes reduce energy usage but may introduce additional
    #   latency when waking devices. Some older or poorly designed PCIe hardware may
    #   behave unpredictably with aggressive ASPM settings. On AC power, performance
    #   and stability are typically prioritized, while on battery moderate savings
    #   are beneficial without risking device issues.
    #
    # Options:
    #   0 = Off
    #   1 = Moderate power savings
    #   2 = Maximum power savings
    #
    # Recommended:
    #   AC = 0  Ensures maximum stability and avoids any latency penalties for
    #            highperformance workloads or sensitive PCIe devices.
    #   DC = 1  Provides meaningful battery savings without the risks associated
    #            with the most aggressive ASPM mode.
    #===============================================================================
    #>
    @{ S="501a4d13-42af-4429-9fd1-a8218c268e20"; G="ee12f906-d277-404b-b6da-e5fa1a576df5"; AC=0; DC=1 },

    <#
    #===============================================================================
    # Minimum processor state
    #
    # Description:
    #   Defines the lowest CPU performance level (as a percentage of maximum) that
    #   the processor is allowed to drop to. Lower minimum states allow deeper idle
    #   power savings, reducing heat and extending battery life. Setting this too
    #   high prevents the CPU from entering efficient lowpower states and wastes
    #   energy. Modern CPUs handle low idle states extremely well, so low values are
    #   generally optimal.
    #
    # Options:
    #   Continuous range: 0100 percent
    #
    # Recommended:
    #   AC = 5  Allows the CPU to idle efficiently without affecting performance
    #            during active workloads.
    #   DC = 5  Provides strong battery savings while maintaining responsiveness
    #            thanks to modern CPU power management.
    #===============================================================================
    #>
    @{ S="54533251-82be-4824-96c1-47b60b740d00"; G="893dee8e-2bef-41e0-89c6-b55d0929964c"; AC=5; DC=5 },

    <#
    #===============================================================================
    # Maximum processor state
    #
    # Description:
    #   Sets the highest CPU performance level allowed. A value of 100% enables full
    #   turbo/boost performance. Reducing this value can significantly lower power
    #   consumption and heat output, especially on battery, but also reduces peak
    #   performance. On AC power, limiting maximum performance is rarely desirable.
    #
    # Options:
    #   Continuous range: 0100 percent
    #
    # Recommended:
    #   AC = 100  Ensures full CPU performance for demanding workloads, gaming,
    #              virtualization, and multitasking.
    #   DC = 85   Reduces heat and power spikes on battery while maintaining strong
    #              performance for typical mobile workloads.
    #===============================================================================
    #>
    @{ S="54533251-82be-4824-96c1-47b60b740d00"; G="bc5038f7-23e0-4960-96da-33abaf5935ec"; AC=100; DC=85 },

    <#
    #===============================================================================
    # System cooling policy
    #
    # Description:
    #   Determines whether the system should increase fan speed (active cooling) or
    #   reduce CPU frequency (passive cooling) when temperatures rise. Active cooling
    #   maintains performance but increases fan noise and power usage. Passive cooling
    #   reduces heat and noise but may throttle performance. On AC power, performance
    #   is typically prioritized; on battery, efficiency and noise reduction matter.
    #
    # Options:
    #   0 = Passive (throttle CPU first)
    #   1 = Active (increase fan speed first)
    #
    # Recommended:
    #   AC = 1  Prioritizes performance and prevents unnecessary throttling during
    #            heavy workloads.
    #   DC = 0  Reduces fan usage and power consumption, extending battery life and
    #            keeping the device quieter.
    #===============================================================================
    #>
    @{ S="54533251-82be-4824-96c1-47b60b740d00"; G="94d3a615-a899-4ac5-ae2b-e4d8f634367f"; AC=1; DC=0 },

    <#
    #===============================================================================
    # Processor performance boost mode
    #
    # Description:
    #   Controls how aggressively the CPU engages turbo/boost frequencies. Higher
    #   boost modes allow the processor to rapidly increase clock speeds for short,
    #   intensive workloads, improving responsiveness and performance. However,
    #   aggressive boosting increases power consumption and heat output. Efficient
    #   modes reduce power draw while still allowing limited boosting when needed.
    #
    # Options:
    #   0 = Disabled (no boost)
    #   1 = Enabled (standard boost)
    #   2 = Aggressive (maximum boost behavior)
    #   3 = Efficient aggressive (balanced boost with efficiency bias)
    #   4 = Efficient (minimal boost, powerfocused)
    #
    # Recommended:
    #   AC = 2  Ensures maximum responsiveness and performance for demanding tasks,
    #            taking full advantage of turbo capabilities.
    #   DC = 3  Provides a strong balance between performance and battery life by
    #            allowing boost but with efficiencyoriented behavior.
    #===============================================================================
    #>
    @{ S="54533251-82be-4824-96c1-47b60b740d00"; G="be337238-0d82-4146-a960-4f3749d470c7"; AC=2; DC=3 },

    <#
    #===============================================================================
    # Legacy PPM increase policy
    #
    # Description:
    #   Determines how aggressively the CPU increases its frequency when load rises.
    #   A more aggressive policy results in faster rampup to higher frequencies,
    #   improving responsiveness but consuming more power. Conservative policies
    #   reduce power usage but may feel less snappy during sudden bursts of activity.
    #
    # Options:
    #   0 = Balanced
    #   1 = Conservative (slow increase)
    #   2 = Aggressive (fast increase)
    #
    # Recommended:
    #   AC = 2  Ensures the CPU responds quickly to workload spikes, improving
    #            system responsiveness and reducing perceived lag.
    #   DC = 0  Balanced behavior avoids unnecessary power spikes while still
    #            providing adequate responsiveness for mobile use.
    #===============================================================================
    #>
    @{ S="54533251-82be-4824-96c1-47b60b740d00"; G="465e1f50-b610-473a-ab58-00d1077dc418"; AC=2; DC=0 },

    <#
    #===============================================================================
    # Legacy PPM decrease policy
    #
    # Description:
    #   Controls how quickly the CPU reduces its frequency when load decreases.
    #   A fast decrease saves power by dropping clocks immediately, while a slower
    #   decrease maintains performance by keeping higher frequencies active longer.
    #   This setting influences both responsiveness and energy efficiency.
    #
    # Options:
    #   0 = Balanced
    #   1 = Slow decrease (hold higher clocks longer)
    #   2 = Fast decrease (drop clocks quickly)
    #
    # Recommended:
    #   AC = 1  Maintains higher performance levels during brief idle periods,
    #            improving responsiveness in bursty workloads.
    #   DC = 2  Reduces power consumption by quickly lowering CPU frequency when
    #            load drops, extending battery life.
    #===============================================================================
    #>
    @{ S="54533251-82be-4824-96c1-47b60b740d00"; G="40fbefc7-2e9d-4d25-a185-0cfd8574bac6"; AC=1; DC=2 },

    <#
    #===============================================================================
    # Core parking minimum cores
    #
    # Description:
    #   Specifies the minimum percentage of CPU cores that must remain unparked
    #   (active) even during low system load. Lower values allow more cores to be
    #   parked, reducing power consumption but potentially increasing latency when
    #   workloads resume. Higher values keep more cores active, improving parallel
    #   responsiveness at the cost of increased power usage.
    #
    # Options:
    #   Continuous range: 0100 percent
    #
    # Recommended:
    #   AC = 50  Keeps enough cores active to maintain strong responsiveness for
    #             multitasking and parallel workloads.
    #   DC = 25  Allows more aggressive core parking to save battery while still
    #             keeping enough cores available for smooth operation.
    #===============================================================================
    #>
    @{ S="54533251-82be-4824-96c1-47b60b740d00"; G="0cc5b647-c1df-4637-891a-dec35c318583"; AC=50; DC=25 },

    <#
    #===============================================================================
    # Core parking maximum cores
    #
    # Description:
    #   Defines the maximum percentage of CPU cores that may remain unparked during
    #   system activity. Setting this to 100% allows all cores to become active when
    #   needed, ensuring full performance. Lower values artificially limit the number
    #   of active cores, reducing performance but saving power.
    #
    # Options:
    #   Continuous range: 0100 percent
    #
    # Recommended:
    #   AC = 100  Ensures the CPU can utilize all available cores for demanding
    #              workloads, maximizing performance.
    #   DC = 100  Allows full multicore performance when required, while other
    #              powersaving mechanisms handle efficiency.
    #===============================================================================
    #>
    @{ S="54533251-82be-4824-96c1-47b60b740d00"; G="ea062031-0e34-4ff1-9b6d-eb1059334028"; AC=100; DC=100 },

    <#
    #===============================================================================
    # HWP Energy Performance Preference (EPP)
    #
    # Description:
    #   Provides a hint to the CPUs hardware power management system (HWP) about
    #   whether to prioritize performance or energy efficiency. Lower values push
    #   the CPU toward higher frequencies and faster responsiveness, while higher
    #   values encourage lower frequencies, reduced voltage, and longer battery life.
    #   This setting is highly effective on modern Intel and AMD processors that
    #   support hardware-guided performance states.
    #
    # Options:
    #   Continuous range: 0100
    #     0   = Maximum performance bias
    #     100 = Maximum efficiency bias
    #
    # Recommended:
    #   AC = 010  Ensures the CPU aggressively prioritizes performance, delivering
    #               fast responsiveness and maximum throughput for demanding tasks.
    #   DC = 4050  Provides a balanced efficiency mode that significantly reduces
    #                power draw while maintaining smooth everyday performance.
    #===============================================================================
    #>
    @{ S="54533251-82be-4824-96c1-47b60b740d00"; G="36687f9e-e3a5-4dbf-b1dc-15eb381c6863"; AC=10; DC=45 },

    <#
    #===============================================================================
    # Legacy PPM increase threshold
    #
    # Description:
    #   Defines the CPU utilization percentage at which the processor begins raising
    #   its frequency. Lower thresholds cause the CPU to ramp up more quickly in
    #   response to small workloads, improving responsiveness. Higher thresholds
    #   delay frequency increases, reducing power consumption but potentially making
    #   the system feel less responsive during light or bursty workloads.
    #
    # Options:
    #   Continuous range: 0100 percent
    #
    # Recommended:
    #   AC = 10  Ensures the CPU reacts quickly to workload changes, improving
    #             responsiveness for interactive tasks and multitasking.
    #   DC = 30  Reduces unnecessary frequency boosts on battery, improving battery
    #             life while still allowing boosts when workloads become heavier.
    #===============================================================================
    #>
    @{ S="54533251-82be-4824-96c1-47b60b740d00"; G="06cadf0e-64ed-448a-8927-ce7bf90eb35d"; AC=10; DC=30 },

    <#
    #===============================================================================
    # Legacy PPM decrease threshold
    #
    # Description:
    #   Determines the CPU utilization percentage at which the processor begins
    #   lowering its frequency. Lower thresholds cause the CPU to drop clocks sooner,
    #   saving power but potentially reducing responsiveness. Higher thresholds keep
    #   the CPU at higher frequencies longer, improving performance at the cost of
    #   increased power usage.
    #
    # Options:
    #   Continuous range: 0100 percent
    #
    # Recommended:
    #   AC = 8   Keeps the CPU at higher frequencies slightly longer, improving
    #             responsiveness during short idle gaps in active workloads.
    #   DC = 20  Allows the CPU to reduce frequency sooner, improving battery life
    #             without noticeably affecting typical mobile performance.
    #===============================================================================
    #>
    @{ S="54533251-82be-4824-96c1-47b60b740d00"; G="12a0ab44-fe28-4fa9-b3bd-4b64f44960a6"; AC=8; DC=20 },

    <#
    #===============================================================================
    # Multimedia: sharing media
    #
    # Description:
    #   Controls how the system behaves when sharing or streaming media over the
    #   network. Preventing sleep ensures uninterrupted playback or streaming, while
    #   allowing sleep conserves power but may interrupt media sessions. Away Mode
    #   keeps the system awake without turning on the display, useful for media
    #   servers or HTPC setups.
    #
    # Options:
    #   0 = Allow the computer to sleep
    #   1 = Prevent the computer from sleeping
    #   2 = Allow Away Mode
    #
    # Recommended:
    #   AC = 1  Prevents interruptions during streaming or media sharing, ensuring
    #            stable playback and uninterrupted network availability.
    #   DC = 0  Allows the system to sleep normally, preventing unnecessary battery
    #            drain when media sharing is not essential on battery power.
    #===============================================================================
    #>
    @{ S="9596fb26-9850-41fd-ac3e-f7c3c00afd4b"; G="03680956-93bc-4294-bba6-4e0f09bb717f"; AC=1; DC=0 },

    <#
    #===============================================================================
    # Multimedia: video playback performance bias
    #
    # Description:
    #   Determines whether video playback should prioritize image quality or power
    #   efficiency. Higher quality modes may increase GPU usage, improving sharpness
    #   and smoothness. Power-saving modes reduce GPU load, extending battery life
    #   but potentially lowering playback quality or frame consistency.
    #
    # Options:
    #   0 = Video playback quality bias
    #   1 = Balanced
    #   2 = Power-saving bias
    #
    # Recommended:
    #   AC = 0  Ensures the best possible video quality, taking advantage of AC
    #            power to maximize clarity and smooth playback.
    #   DC = 1  Balanced mode reduces power usage while maintaining good playback
    #            quality, ideal for mobile viewing without excessive battery drain.
    #===============================================================================
    #>
    @{ S="9596fb26-9850-41fd-ac3e-f7c3c00afd4b"; G="10778347-1370-4ee0-8bbd-33bdacaade49"; AC=0; DC=1 },

    <#
    #===============================================================================
    # Multimedia: video playback quality bias
    #
    # Description:
    #   Controls the systems preference for video playback quality versus power
    #   efficiency. Qualitybiased modes prioritize sharper image rendering, higher
    #   bitrates, and smoother playback, which increases GPU usage. Balanced modes
    #   reduce GPU load while maintaining acceptable quality. Powersaving modes
    #   minimize GPU activity, extending battery life at the cost of visual fidelity.
    #
    # Options:
    #   0 = Quality bias
    #   1 = Balanced
    #   2 = Powersaving bias
    #
    # Recommended:
    #   AC = 0  Ensures the highest possible video quality, taking advantage of
    #            unlimited AC power for smooth and detailed playback.
    #   DC = 1  Balanced mode maintains good visual quality while reducing GPU
    #            power consumption, ideal for mobile viewing.
    #===============================================================================
    #>
    @{ S="9596fb26-9850-41fd-ac3e-f7c3c00afd4b"; G="34c7b99f-9a6d-4b3c-8dc7-b6693b78cef4"; AC=0; DC=1 },

    <#
    #===============================================================================
    # Critical battery notification
    #
    # Description:
    #   Determines whether Windows displays a warning when the battery reaches a
    #   critically low level. This notification gives the user a final chance to
    #   save work before the system performs an emergency action such as hibernation
    #   or shutdown. Disabling this notification risks sudden data loss.
    #
    # Options:
    #   0 = Disabled
    #   1 = Enabled
    #
    # Recommended:
    #   AC = 1  Even on AC power, unexpected disconnections can occur; the warning
    #            provides essential protection against data loss.
    #   DC = 1  Critical for preventing sudden shutdowns when battery levels drop
    #            faster than expected.
    #===============================================================================
    #>
    @{ S="e73a048d-bf27-4f12-9731-8b2076e8891f"; G="5dbb7c9f-38e9-40d2-9749-4f8a0e9f640f"; AC=1; DC=1 },

    <#
    #===============================================================================
    # Critical battery action
    #
    # Description:
    #   Specifies what the system should do when the battery reaches a critically
    #   low level. Hibernate is the safest option because it preserves the session
    #   to disk and prevents data loss even if the battery fully depletes. Shutdown
    #   is faster but risks losing unsaved work. Sleep is unsafe at critical levels
    #   because the system may run out of power before resuming.
    #
    # Options:
    #   0 = Do nothing
    #   1 = Sleep
    #   2 = Hibernate
    #   3 = Shut down
    #
    # Recommended:
    #   AC = 2  Provides maximum safety in case of unexpected AC loss or power
    #            interruptions, preserving the session reliably.
    #   DC = 2  Prevents data loss by ensuring the system enters a nonvolatile
    #            state before the battery is fully depleted.
    #===============================================================================
    #>
    @{ S="e73a048d-bf27-4f12-9731-8b2076e8891f"; G="637ea02f-bbcb-4015-8e2c-a1c7b9c0b546"; AC=2; DC=2 },

    <#
    #===============================================================================
    # Low battery level
    #
    # Description:
    #   Defines the battery percentage at which Windows considers the battery low.
    #   This threshold triggers lowbattery notifications and can initiate optional
    #   powersaving actions. Setting this too low reduces warning time; setting it
    #   too high causes unnecessary alerts. A moderate value provides a good balance
    #   between early warning and minimal disruption.
    #
    # Options:
    #   Continuous range: 0100 percent
    #
    # Recommended:
    #   AC = 10  Provides a reasonable early warning without being intrusive when
    #             the system is plugged in most of the time.
    #   DC = 15  Gives additional buffer on battery, ensuring the user has enough
    #             time to save work or connect to power.
    #===============================================================================
    #>
    @{ S="e73a048d-bf27-4f12-9731-8b2076e8891f"; G="8183ba9a-e910-48da-8769-14ae6dc1170a"; AC=10; DC=15 },

    <#
    #===============================================================================
    # Critical battery level
    #
    # Description:
    #   Determines the battery percentage at which the system considers the battery
    #   critical. At this level, Windows performs the critical battery action to
    #   prevent data loss. A value that is too low risks the system shutting down
    #   before the action can complete; too high wastes usable battery capacity.
    #
    # Options:
    #   Continuous range: 0100 percent
    #
    # Recommended:
    #   AC = 5  Provides a safe threshold while maximizing usable battery capacity.
    #   DC = 5  Ensures the system has enough time to enter hibernation before the
    #            battery is fully depleted.
    #===============================================================================
    #>
    @{ S="e73a048d-bf27-4f12-9731-8b2076e8891f"; G="9a66d8d7-4ff7-4ef9-b5a2-5a326ca2a469"; AC=5; DC=5 },

    <#
    #===============================================================================
    # Low battery notification
    #
    # Description:
    #   Controls whether Windows alerts the user when the battery reaches the low
    #   threshold. This early warning is important because it gives the user time to
    #   save work, reduce power usage, or connect the device to a charger. Disabling
    #   this notification removes an important safety net and increases the risk of
    #   unexpected shutdowns, especially during mobile use.
    #
    # Options:
    #   0 = Disabled
    #   1 = Enabled
    #
    # Recommended:
    #   AC = 1  Even when plugged in, accidental disconnections or loose adapters
    #            can cause the battery to drain unexpectedly; the warning prevents
    #            surprise power loss.
    #   DC = 1  Essential for mobile use, ensuring the user receives timely alerts
    #            before the system reaches critical levels.
    #===============================================================================
    #>
    @{ S="e73a048d-bf27-4f12-9731-8b2076e8891f"; G="bcded951-187b-4d05-bccc-f7e51960c258"; AC=1; DC=1 },

    <#
    #===============================================================================
    # Low battery action
    #
    # Description:
    #   Determines what the system should do when the battery reaches the low
    #   threshold. Unlike the critical battery action, this is a gentler response
    #   intended to encourage the user to take action without forcing a full system
    #   state change. Sleep is a reasonable compromise: it conserves power while
    #   preserving the session, but still allows quick resume.
    #
    # Options:
    #   0 = Do nothing
    #   1 = Sleep
    #   2 = Hibernate
    #   3 = Shut down
    #
    # Recommended:
    #   AC = 0  On AC power, low battery events are rare and usually caused by
    #            accidental unplugging; no automatic action is needed.
    #   DC = 1  Sleep provides a gentle safeguard that prevents excessive battery
    #            drain while giving the user time to reconnect to power.
    #===============================================================================
    #>
    @{ S="e73a048d-bf27-4f12-9731-8b2076e8891f"; G="d8742dcb-3e6a-4b3c-b3fe-374623cdcf06"; AC=0; DC=1 },

    <#
    #===============================================================================
    # Reserve battery level
    #
    # Description:
    #   Defines the battery percentage that Windows treats as a reserve buffer.
    #   When the battery falls below this level, Windows may take additional steps
    #   to conserve power and extend remaining runtime. This reserve helps prevent
    #   sudden shutdowns caused by battery wear, inaccurate charge reporting, or
    #   rapid discharge under heavy load.
    #
    # Options:
    #   Continuous range: 0100 percent
    #
    # Recommended:
    #   AC = 57   Provides a small but useful buffer without interfering with
    #               normal operation when the device is plugged in.
    #   DC = 710  Offers extra protection during mobile use, accounting for
    #               battery aging and unpredictable discharge behavior.
    #===============================================================================
    #>
    @{ S="e73a048d-bf27-4f12-9731-8b2076e8891f"; G="f3c5027d-cd16-4930-aa6b-90db844a8f00"; AC=7; DC=10 }

)

$appliedCount = 0
$targetPlanGuid = "57696e68-616e-6365-506f-776572000000"
foreach ($setting in $settings) {
    try {
        powercfg /setacvalueindex $targetPlanGuid $setting.S $setting.G $setting.AC 2>$null
        if ($LASTEXITCODE -eq 0) {
            powercfg /setdcvalueindex $targetPlanGuid $setting.S $setting.G $setting.DC 2>$null
            if ($LASTEXITCODE -eq 0) {
                $appliedCount++
            }
        }
    } catch {
    }
}
Write-Output "Applied $appliedCount power settings"

Write-Output "Activating power plan..."
powercfg /setactive 57696e68-616e-6365-506f-776572000000 2>$null
if ($LASTEXITCODE -eq 0) {
    Write-Output "Power plan activated successfully"
} else {
    Write-Output "Failed to activate power plan"
}

$entries = @(
    @{
        Path = "HKLM:\SYSTEM\ControlSet001\Control\Session Manager\Power"
        Name = "HiberbootEnabled"
        Type = "DWord"
        Value = 0
        Description = "Disables Fast Startup by preventing Windows from using a hibernated system state during shutdown."
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FlyoutMenuSettings"
        Name = "ShowHibernateOption"
        Type = "DWord"
        Value = 1
        Description = "Enables the Hibernate option in the Start Menu power flyout."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Control\Power\PowerThrottling"
        Name = "PowerThrottlingOff"
        Type = "DWord"
        Value = 1
        Description = "Disables power throttling to prevent Windows from reducing CPU performance for background processes."
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FlyoutMenuSettings"
        Name = "ShowLockOption"
        Type = "DWord"
        Value = 1
        Description = "Enables the Lock option in the Start Menu power flyout."
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FlyoutMenuSettings"
        Name = "ShowSleepOption"
        Type = "DWord"
        Value = 1
        Description = "Enables the Sleep option in the Start Menu power flyout."
    }
)
Apply-RegistryBatch $entries
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\ConfigureWindowsUpdate.System.ps1">
<![CDATA[
. "C:\MySetup\Scripts\Apply-Registry.ps1"

$entries = @(
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU"
        Name = "AUOptions"
        Type = "DWord"
        Value = 4
        Description="Control how automatic updates behave"
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DeliveryOptimization"
        Name = "DODownloadMode"
        Type = "DWord"
        Value = 99
        Description="Share downloaded updates with other PCs on your network or the internet to reduce bandwidth usage"
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings"
        Name = "IsContinuousInnovationOptedIn"
        Type = "DWord"
        Value = 0
        Description="Be among the first to get the latest non-security updates, fixes, and improvements as they roll out"
    },
    @{
        Path = "HKLM:\Software\Microsoft\WindowsUpdate\UX\Settings"
        Name = "AllowMUUpdateService"
        Type = "DWord"
        Value = 0
        Description="Get Microsoft Office and other updates together with Windows updates"
    },
    @{
        Path = "HKLM:\Software\Microsoft\WindowsUpdate\UX\Settings"
        Name = "IsExpedited"
        Type = "DWord"
        Value = 0
        Description="Restart as soon as possible (even during active hours) to finish updating"
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU"
        Name = "NoAutoRebootWithLoggedOnUsers"
        Type = "DWord"
        Value = 1
        Description="Prevents automatic restarts after installing updates when users are logged on"
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate"
        Name = "SetUpdateNotificationLevel"
        Type = "DWord"
        Value = 1
        Description="Show or hide notifications about available updates and update progress"
    },
    @{
        Path = "HKLM:\Software\Microsoft\WindowsUpdate\UX\Settings"
        Name = "RestartNotificationsAllowed2"
        Type = "DWord"
        Value = 0
        Description="Show notification when your device requires a restart to finish updating"
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings"
        Name = "AllowAutoWindowsUpdateDownloadOverMeteredNetwork"
        Type = "DWord"
        Value = 0
        Description="Allow Windows to download updates when using mobile hotspots or data-limited connections"
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate"
        Name = "ExcludeWUDriversInQualityUpdate"
        Type = "DWord"
        Value = 1
        Description="Prevent Windows from automatically downloading and installing hardware driver updates"
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\WindowsStore"
        Name = "AutoDownload"
        Type = "DWord"
        Value = 2
        Description="Automatically download and install updates for apps from the Microsoft Store"
    }
)
Apply-RegistryBatch $entries

Register-ScheduledTask -TaskName 'PauseWindowsUpdate' -Xml $( Get-Content -LiteralPath 'C:\MySetup\Scripts\PauseWindowsUpdate.xml' -Raw );

Register-ScheduledTask -TaskName 'MoveActiveHoursPrimary' -Xml $( Get-Content -LiteralPath 'C:\MySetup\Scripts\MoveActiveHoursPrimary.xml' -Raw );
Register-ScheduledTask -TaskName 'MoveActiveHoursBackup' -Xml $( Get-Content -LiteralPath 'C:\MySetup\Scripts\MoveActiveHoursBackup.xml' -Raw );
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\ConfigureWindowsAI.System.ps1">
<![CDATA[
. "C:\MySetup\Scripts\Apply-Registry.ps1"

$entries = @(
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsCopilot"
        Name = "TurnOffWindowsCopilot"
        Type = "DWord"
        Value = 1
        Description = "Disables the Windows Copilot feature for the system."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsAI"
        Name = "DisableAIDataAnalysis"
        Type = "DWord"
        Value = 1
        Description = "Prevents Windows AI components from analyzing user data."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsAI"
        Name = "DisableAIRecall"
        Type = "DWord"
        Value = 1
        Description = "Disables the Windows Recall feature in Windows AI."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\System"
        Name = "DisableSuggestions"
        Type = "DWord"
        Value = 1
        Description = "Turns off Suggested Actions within the Windows system UI."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Dsh"
        Name = "AllowNewsAndInterests"
        Type = "DWord"
        Value = 0
        Description = "Disables the News and Interests widget on the taskbar."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\Windows Feeds"
        Name = "EnableFeeds"
        Type = "DWord"
        Value = 0
        Description = "Disables Windows Feeds and related widget content."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\Windows Search"
        Name = "DisableSearchBoxSuggestions"
        Type = "DWord"
        Value = 1
        Description = "Disables AI-powered search box suggestions in Windows Search."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\Windows Search"
        Name = "ConnectedSearchUseWeb"
        Type = "DWord"
        Value = 0
        Description = "Prevents Windows Search from using web-based results."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\Windows Search"
        Name = "AllowSearchToUseLocation"
        Type = "DWord"
        Value = 0
        Description = "Blocks Windows Search from accessing the device's location."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\Explorer"
        Name = "HideRecommendedSection"
        Type = "DWord"
        Value = 1
        Description = "Hides the Recommended section in the Start Menu."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\CloudContent"
        Name = "DisableTailoredExperiencesWithDiagnosticData"
        Type = "DWord"
        Value = 1
        Description = "Disables personalized experiences based on diagnostic data."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\CloudContent"
        Name = "DisableConsumerFeatures"
        Type = "DWord"
        Value = 1
        Description = "Disables consumer-focused cloud content and features."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\InputPersonalization"
        Name = "AllowInputPersonalization"
        Type = "DWord"
        Value = 0
        Description = "Prevents Windows from personalizing typing and input behavior."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\InputPersonalization"
        Name = "RestrictImplicitTextCollection"
        Type = "DWord"
        Value = 1
        Description = "Blocks Windows from collecting text input for AI learning."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\InputPersonalization"
        Name = "RestrictImplicitInkCollection"
        Type = "DWord"
        Value = 1
        Description = "Blocks Windows from collecting handwriting input for AI learning."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\WindowsStore"
        Name = "DisableStoreApps"
        Type = "DWord"
        Value = 1
        Description = "Prevents the Microsoft Store from updating system components."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\Windows Feeds"
        Name = "AllowWebExperiencePackUpdates"
        Type = "DWord"
        Value = 0
        Description = "Blocks updates to the Web Experience Pack, including widget and Copilot components."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\CloudContent"
        Name = "DisableOnlineContent"
        Type = "DWord"
        Value = 1
        Description = "Disables Online Service Experience Packs and cloud-delivered content."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\AppPrivacy"
        Name = "LetAppsRunAI"
        Type = "DWord"
        Value = 0
        Description = "Prevents inbox apps from using AI-powered preview features."
    },
    @{
        Path = "HKLM\SOFTWARE\Policies\Microsoft\Windows\CloudContent"
        Name = "DisableWindowsSpotlightFeatures"
        Type = "DWord"
        Value = 1
        Description = "Disables Windows Spotlight and its AI-driven content recommendations."
    }
)
Apply-RegistryBatch $entries
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\ConfigureSecurityAndPrivacy.System.ps1">
<![CDATA[
. "C:\MySetup\Scripts\Apply-Registry.ps1"

$entries = @(
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
        Name = "ConsentPromptBehaviorAdmin"
        Type = "DWord"
        Value = 0
        Description = "Defines how Windows prompts administrators for approval when elevated permissions are required."
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
        Name = "PromptOnSecureDesktop"
        Type = "DWord"
        Value = 0
        Description = "Determines whether UAC prompts appear on the secure desktop for added protection."
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WorkplaceJoin"
        Name = "BlockAADWorkplaceJoin"
        Type = "DWord"
        Value = 1
        Description = "Prevents users from joining Azure AD or seeing prompts to let the organization manage the device."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Control\BitLocker"
        Name = "PreventDeviceEncryption"
        Type = "DWord"
        Value = 1
        Description = "Stops Windows from automatically enabling BitLocker device encryption."
    },
    @{
        Path = "HKLM:\Software\Microsoft\PolicyManager\default\WiFi\AllowWiFiHotSpotReporting"
        Name = "Value"
        Type = "DWord"
        Value = 0
        Description = "Disables WiFi Sense features that share WiFi credentials and connect to suggested hotspots."
    },
    @{
        Path = "HKLM:\Software\Microsoft\PolicyManager\default\WiFi\AllowAutoConnectToWiFiSenseHotspots"
        Name = "Value"
        Type = "DWord"
        Value = 0
        Description = "Prevents automatic connection to open or suggested WiFi Sense hotspots."
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\Maintenance"
        Name = "MaintenanceDisabled"
        Type = "DWord"
        Value = 1
        Description = "Disables automatic system maintenance tasks that normally run during idle time."
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Windows Error Reporting"
        Name = "Disabled"
        Type = "DWord"
        Value = 1
        Description = "Turns off Windows Error Reporting so crash and diagnostic data is not sent to Microsoft."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Control\Remote Assistance"
        Name = "fAllowToGetHelp"
        Type = "DWord"
        Value = 0
        Description = "Blocks Remote Assistance so others cannot connect to provide remote help."
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
        Name = "DisableLockWorkstation"
        Type = "DWord"
        Value = 0
        Description = "Controls whether users are allowed to lock the workstation using Windows security shortcuts."
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\AdvertisingInfo"
        Name = "DisabledByGroupPolicy"
        Type = "DWord"
        Value = 1
        Description = "Disables the advertising ID used by apps to deliver personalized ads."
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\DataCollection"
        Name = "AllowTelemetry"
        Type = "DWord"
        Value = 1
        Description = "Sets the level of diagnostic data Windows is allowed to send to Microsoft."
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\DataCollection"
        Name = "MaxTelemetryAllowed"
        Type = "DWord"
        Value = 1
        Description = "Defines the maximum diagnostic data level permitted on the device."
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DataCollection"
        Name = "AllowTelemetry"
        Type = "DWord"
        Value = 1
        Description = "Specifies whether diagnostic data collection is permitted by policy."
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DataCollection"
        Name = "DoNotShowFeedbackNotifications"
        Type = "DWord"
        Value = 1
        Description = "Suppresses Windows feedback notifications that request user input."
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Windows Search"
        Name = "AllowCortana"
        Type = "DWord"
        Value = 0
        Description = "Enables or disables the Cortana assistant for search and voice interaction."
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore\location"
        Name = "Value"
        Type = "String"
        Value = "Deny"
        Description = "Controls whether Windows and apps are allowed to access the devices location."
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\LocationAndSensors"
        Name = "DisableLocation"
        Type = "DWord"
        Value = 1
        Description = "Disables all location services and prevents apps from accessing location data."
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore\webcam"
        Name = "Value"
        Type = "String"
        Value = "Allow"
        Description = "Specifies whether apps are permitted to access the device camera."
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore\microphone"
        Name = "Value"
        Type = "String"
        Value = "Allow"
        Description = "Specifies whether apps are permitted to access the device microphone."
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore\userAccountInformation"
        Name = "Value"
        Type = "String"
        Value = "Deny"
        Description = "Controls whether apps can access user account information."
    },
    @{
        Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore\appDiagnostics"
        Name = "Value"
        Type = "String"
        Value = "Deny"
        Description = "Controls whether apps can access diagnostic information about other apps."
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\OneDrive"
        Name = "KFMBlockOptIn"
        Type = "DWord"
        Value = 1
        Description = "Prevents OneDrive from offering or enabling automatic backup of user folders."
    }
)
Apply-RegistryBatch $entries
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\ConfigurePerformance.System.ps1">
<![CDATA[
. "C:\MySetup\Scripts\Apply-Registry.ps1"

$entries = @(
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\AppPrivacy"
        Name = "LetAppsRunInBackground"
        Type = "DWord"
        Value = 0
        Description = "Controls whether Windows allows apps to run background processes."
    },
    @{
        Path = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\StorageSense"
        Name = "AllowStorageSenseGlobal"
        Type = "DWord"
        Value = 0
        Description = "Enables or disables the Storage Sense automatic cleanup feature."
    },
    @{
        Path = "HKLM:\System\CurrentControlSet\Control\PriorityControl"
        Name = "Win32PrioritySeparation"
        Type = "DWord"
        Value = 38
        Description = "Adjusts how Windows prioritizes CPU time between foreground and background tasks."
    },
    @{
        Path = "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Multimedia\SystemProfile"
        Name = "SystemResponsiveness"
        Type = "DWord"
        Value = 10
        Description = "Defines how much system resources are reserved for background multimedia tasks."
    },
    @{
        Path = "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Multimedia\SystemProfile\Tasks\Games"
        Name = "Priority"
        Type = "DWord"
        Value = 6
        Description = "Sets the CPU scheduling priority level for game-related processes."
    },
    @{
        Path = "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Multimedia\SystemProfile\Tasks\Games"
        Name = "Scheduling Category"
        Type = "String"
        Value = 'High'
        Description = "Specifies the scheduling category assigned to game tasks."
    },
    @{
        Path = "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Multimedia\SystemProfile\Tasks\Games"
        Name = "GPU Priority"
        Type = "DWord"
        Value = 8
        Description = "Determines the GPU scheduling priority for game workloads."
    },
    @{
        Path = "HKLM:\System\CurrentControlSet\Control\GraphicsDrivers"
        Name = "HwSchMode"
        Type = "DWord"
        Value = 2
        Description = "Enables or configures hardware-accelerated GPU scheduling."
    },
    @{
        Path = "HKLM:\Software\NVIDIA Corporation\Global\FTS"
        Name = "EnableGR535"
        Type = "DWord"
        Value = 0
        Description = "Toggles NVIDIAs legacy image-sharpening feature."
    },
    @{
        Path = "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Multimedia\SystemProfile"
        Name = "NetworkThrottlingIndex"
        Type = "DWord"
        Value = 10
        Description = "Controls Windows network throttling behavior for multimedia and gaming traffic."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters"
        Name = "TcpAckFrequency"
        Type = "DWord"
        Value = 2
        Description = "Sets how frequently TCP sends acknowledgment packets."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters"
        Name = "TCPNoDelay"
        Type = "DWord"
        Value = 0
        Description = "Enables or disables Nagles algorithm for TCP packet batching."
    },
    @{
        Path = "HKLM:\Software\Microsoft\Windows\CurrentVersion\GameConfigStore"
        Name = "AllowGameDVR"
        Type = "DWord"
        Value = 0
        Description = "Controls whether the Xbox Game Bar is allowed to record gameplay and capture screenshots."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Control"
        Name = "ServicesPipeTimeout"
        Type = "DWord"
        Value = 30000
        Description = "Defines how long Windows waits for services to start before timing out."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\SysMain"
        Name = "Start"
        Type = "DWord"
        Value = 4
        Description = "Controls whether the SysMain service (Superfetch) is enabled for application preloading."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters"
        Name = "EnablePrefetcher"
        Type = "DWord"
        Value = 0
        Description = "Enables or disables Windows Prefetching for faster application and boot loading."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\WSearch"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Controls whether the Windows Search indexing service is enabled."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\Spooler"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Determines whether the Print Spooler service is enabled to manage print jobs."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\DiagTrack"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Controls the Connected User Experiences and Telemetry service for diagnostic data collection."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\PcaSvc"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Manages the Program Compatibility Assistant service that detects compatibility issues."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\WerSvc"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Controls the Windows Error Reporting service responsible for crash data collection."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\lfsvc"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Manages the Geolocation service used by apps to access device location."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\RetailDemo"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Controls the Retail Demo service used for instore demonstration mode."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\wisvc"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Manages Windows Insider Program services and preview build functionality."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\PhoneSvc"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Controls the Phone Service responsible for telephony features on Windows devices."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\WalletService"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Manages the Microsoft Wallet service for payment and NFC features."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\SCardSvr"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Controls the Smart Card service used for authentication with smart card devices."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\ScDeviceEnum"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Handles enumeration of smart card devices for authentication purposes."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\SCPolicySvc"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Manages smart card security policies for authentication operations."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\MapsBroker"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Controls the Maps Broker service that provides access to offline maps."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\Fax"
        Name = "Start"
        Type = "DWord"
        Value = 4
        Description = "Controls the Fax service used for sending and receiving faxes."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\WMPNetworkSvc"
        Name = "Start"
        Type = "DWord"
        Value = 4
        Description = "Manages network sharing of Windows Media Player libraries."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\MixedRealityOpenXRSvc"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Runs the OpenXR service required for Windows Mixed Reality applications."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\icssvc"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Controls the Internet Connection Sharing service used to share a network connection with other devices."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\SmsRouter"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Manages routing of SMS messages for devices that support messaging features."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\WpcMonSvc"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Runs the Family Safety monitoring service for parental control features."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\SEMgrSvc"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Handles secure element management for NFC and payment-related functionality."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\svsvc"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Runs the Spot Verifier service to check for potential file system corruption."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\RasMan"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Manages VPN, dialup, and remote access connections."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\RasAuto"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Automatically establishes remote connections when applications access remote resources."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\TermService"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Enables Remote Desktop connections to the computer."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\SessionEnv"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Manages Remote Desktop session settings and environment configuration."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\UmRdpService"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Provides device redirection support for Remote Desktop sessions."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\BITS"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Handles background file transfers such as Windows Update downloads."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\XblAuthManager"
        Name = "Start"
        Type = "DWord"
        Value = 4
        Description = "Provides authentication services required for Xbox Live functionality."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\XblGameSave"
        Name = "Start"
        Type = "DWord"
        Value = 4
        Description = "Manages cloud save synchronization for Xbox-enabled games."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\XboxNetApiSvc"
        Name = "Start"
        Type = "DWord"
        Value = 4
        Description = "Supports Xbox Live networking features including multiplayer connectivity."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\WbioSrvc"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Runs the Windows Biometric Service for fingerprint and facial recognition."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\TabletInputService"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Provides touch keyboard, handwriting, and pen input functionality."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\SensrSvc"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Monitors system sensors such as orientation and ambient light."
    },
    @{
        Path = "HKLM:\SYSTEM\CurrentControlSet\Services\SensorDataService"
        Name = "Start"
        Type = "DWord"
        Value = 3
        Description = "Supplies sensor data from hardware sensors to applications."
    }
)

$scheduledTasks = @(
    @{ TN="\Microsoft\Windows\Application Experience\Microsoft Compatibility Appraiser"; Action="/Disable"; Desc="Evaluates system and application compatibility for Windows upgrades." },
    @{ TN="\Microsoft\Windows\Application Experience\ProgramDataUpdater"; Action="/Disable"; Desc="Updates the systems program compatibility data." },
    @{ TN="\Microsoft\Windows\Customer Experience Improvement Program\Consolidator"; Action="/Disable"; Desc="Aggregates and sends Customer Experience Improvement Program telemetry." },
    @{ TN="\Microsoft\Windows\Customer Experience Improvement Program\UsbCeip"; Action="/Disable"; Desc="Collects telemetry related to USB device usage." },
    @{ TN="\Microsoft\Windows\DiskDiagnostic\Microsoft-Windows-DiskDiagnosticDataCollector"; Action="/Disable"; Desc="Gathers disk health and diagnostic information." },
    @{ TN="\Microsoft\Windows\Feedback\Siuf\DmClient"; Action="/Disable"; Desc="Collects user feedback and diagnostic data for Microsoft." },
    @{ TN="\Microsoft\Windows\Feedback\Siuf\DmClientOnScenarioDownload"; Action="/Disable"; Desc="Downloads configuration data for feedback and diagnostic scenarios." },
    @{ TN="\Microsoft\Windows\Windows Error Reporting\QueueReporting"; Action="/Disable"; Desc="Queues and processes Windows error and crash reports." },
    @{ TN="\Microsoft\Windows\PI\Sqm-Tasks"; Action="/Disable"; Desc="Collects software quality and reliability metrics." },
    @{ TN="\Microsoft\Windows\Application Experience\MareBackup"; Action="/Disable"; Desc="Backs up data used by Microsoft Assisted Recovery." },
    @{ TN="\Microsoft\Windows\Application Experience\StartupAppTask"; Action="/Disable"; Desc="Monitors startup applications for compatibility and diagnostics." },
    @{ TN="\Microsoft\Windows\Application Experience\PcaPatchDbTask"; Action="/Disable"; Desc="Updates the Program Compatibility Assistants patch database." },
    @{ TN="\Microsoft\Windows\Maps\MapsUpdateTask"; Action="/Disable"; Desc="Updates offline map data for the Maps application." },
    @{ TN="\Microsoft\Windows\Autochk\Proxy"; Action="/Disable"; Desc="Runs scheduled disk check and diagnostic tasks." },
    @{ TN="\Microsoft\Windows\Shell\FamilySafetyMonitor"; Action="/Disable"; Desc="Monitors activity for Microsoft Family Safety features." },
    @{ TN="\Microsoft\Windows\Power Efficiency Diagnostics\AnalyzeSystem"; Action="/Disable"; Desc="Analyzes system power usage for efficiency diagnostics." }
)

Write-Output "Applying scheduled task settings..."
$processedCount = 0
foreach ($task in $scheduledTasks) {
    try {
        $result = & cmd.exe /c "schtasks /Change /TN `"$($task.TN)`" $($task.Action)" 2>&1
        if ($LASTEXITCODE -eq 0) {
            Write-Output "$($task.Desc)"
            $processedCount++
        } else {
            Write-Output "Task command failed for: $($task.Desc)"
        }
    } catch {
        Write-Output "Failed to process task: $($task.Desc) - $($_.Exception.Message)"
    }
}
Write-Output "Processed $processedCount scheduled task settings"
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\PauseWindowsUpdate.ps1">
<![CDATA[
& {
    $formatter = {
        $args[0].ToString( "yyyy'-'MM'-'dd'T'HH':'mm':'ssK" );
    };
    $now = [datetime]::UtcNow;
    $start = & $formatter $now;
    $end = & $formatter $now.AddDays( 7.1 );

    $params = @{
        LiteralPath = 'Registry::HKLM\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings';
        Type = 'String';
        Force = $true;
    };

    Set-ItemProperty @params -Name 'PauseFeatureUpdatesStartTime' -Value $start;
    Set-ItemProperty @params -Name 'PauseFeatureUpdatesEndTime' -Value $end;
    Set-ItemProperty @params -Name 'PauseQualityUpdatesStartTime' -Value $start;
    Set-ItemProperty @params -Name 'PauseQualityUpdatesEndTime' -Value $end;
    Set-ItemProperty @params -Name 'PauseUpdatesStartTime' -Value $start;
    Set-ItemProperty @params -Name 'PauseUpdatesExpiryTime' -Value $end;
} *>&1 | Out-String -Width 1KB -Stream >> "C:\MySetup\Logs\PauseWindowsUpdate.log";
]]>
		</File>
		<File path="C:\Windows\Setup\Scripts\PauseWindowsUpdate.xml">
<![CDATA[
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <CalendarTrigger>
      <StartBoundary>2026-01-01T12:00:00-08:00</StartBoundary>
      <Enabled>true</Enabled>
      <ScheduleByDay>
        <DaysInterval>1</DaysInterval>
      </ScheduleByDay>
    </CalendarTrigger>
    <BootTrigger>
      <Enabled>true</Enabled>
    </BootTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <Enabled>true</Enabled>
    <Hidden>false</Hidden>
    <RunOnlyIfIdle>false</RunOnlyIfIdle>
    <WakeToRun>true</WakeToRun>
    <ExecutionTimeLimit>PT5M</ExecutionTimeLimit>
    <Priority>7</Priority>
    <RestartOnFailure>
      <Interval>PT5M</Interval>
      <Count>5</Count>
    </RestartOnFailure>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</Command>
      <Arguments>-ExecutionPolicy "Unrestricted" -NoProfile -File "C:\MySetup\Scripts\PauseWindowsUpdate.ps1"</Arguments>
    </Exec>
  </Actions>
</Task>
]]>
		</File>
        <File path="C:\Windows\Setup\Scripts\MoveActiveHours.vbs">
<![CDATA[
HKLM = &H80000002
key = "SOFTWARE\Microsoft\WindowsUpdate\UX\Settings"
Set reg = GetObject("winmgmts://./root/default:StdRegProv")
current = Hour(Now)
reg.SetDWORDValue HKLM, key, "ActiveHoursStart", ( current + 23 ) Mod 24
reg.SetDWORDValue HKLM, key, "ActiveHoursEnd", ( current + 11 ) Mod 24
reg.SetDWORDValue HKLM, key, "SmartActiveHoursState", 2
]]>
		</File>
		<File path="C:\Windows\Setup\Scripts\MoveActiveHoursPrimary.xml">
<![CDATA[
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <BootTrigger>
      <Enabled>true</Enabled>
    </BootTrigger>
    <CalendarTrigger>
      <StartBoundary>2026-01-01T00:00:00</StartBoundary>
      <Enabled>true</Enabled>
      <ScheduleByDay>
        <DaysInterval>1</DaysInterval>
      </ScheduleByDay>
      <Repetition>
        <Interval>PT4H</Interval>
        <StopAtDurationEnd>false</StopAtDurationEnd>
      </Repetition>
    </CalendarTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <Enabled>true</Enabled>
    <Hidden>false</Hidden>
    <RunOnlyIfIdle>false</RunOnlyIfIdle>
    <WakeToRun>false</WakeToRun>
    <ExecutionTimeLimit>PT5M</ExecutionTimeLimit>
    <Priority>7</Priority>
    <RestartOnFailure>
      <Interval>PT5M</Interval>
      <Count>5</Count>
    </RestartOnFailure>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>C:\Windows\System32\wscript.exe</Command>
      <Arguments>"C:\MySetup\Scripts\MoveActiveHours.vbs" &gt;&gt; "C:\MySetup\Logs\MoveActiveHours.log" 2&gt;&amp;1</Arguments>
    </Exec>
  </Actions>
</Task>
]]>
		</File>
        <File path="C:\Windows\Setup\Scripts\MoveActiveHoursBackup.xml">
<![CDATA[
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <BootTrigger>
      <Enabled>true</Enabled>
    </BootTrigger>
    <CalendarTrigger>
      <StartBoundary>2026-01-01T00:05:00</StartBoundary>
      <Enabled>true</Enabled>
      <ScheduleByDay>
        <DaysInterval>1</DaysInterval>
      </ScheduleByDay>
      <Repetition>
        <Interval>PT8H</Interval>
        <StopAtDurationEnd>false</StopAtDurationEnd>
      </Repetition>
    </CalendarTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <Enabled>true</Enabled>
    <Hidden>false</Hidden>
    <RunOnlyIfIdle>false</RunOnlyIfIdle>
    <WakeToRun>true</WakeToRun>
    <ExecutionTimeLimit>PT5M</ExecutionTimeLimit>
    <Priority>7</Priority>
    <RestartOnFailure>
      <Interval>PT5M</Interval>
      <Count>5</Count>
    </RestartOnFailure>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>C:\Windows\System32\wscript.exe</Command>
      <Arguments>"C:\MySetup\Scripts\MoveActiveHours.vbs" &gt;&gt; "C:\MySetup\Logs\MoveActiveHours.log" 2&gt;&amp;1</Arguments>
    </Exec>
  </Actions>
</Task>
]]>
		</File>
        <File path="C:\Windows\Setup\Scripts\UserSetup.FirstUser.xml">
<![CDATA[
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <LogonTrigger>
      <Enabled>true</Enabled>
      <Delay>PT30S</Delay>
    </LogonTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <LogonType>InteractiveToken</LogonType>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <IdleSettings>
      <StopOnIdleEnd>false</StopOnIdleEnd>
      <RestartOnIdle>false</RestartOnIdle>
    </IdleSettings>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <Enabled>true</Enabled>
    <Hidden>false</Hidden>
    <RunOnlyIfIdle>false</RunOnlyIfIdle>
    <WakeToRun>false</WakeToRun>
    <ExecutionTimeLimit>PT0S</ExecutionTimeLimit>
    <Priority>5</Priority>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</Command>
      <Arguments>-NoProfile -ExecutionPolicy Bypass -File "C:\MySetup\Scripts\UserSetup.ps1" FirstUser</Arguments>
    </Exec>
  </Actions>
</Task>
]]>
        </File>
    </Extensions>
</unattend>