<?xml version="1.0" encoding="utf-8"?>
<unattend xmlns="urn:schemas-microsoft-com:unattend" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State">
	<!--https://schneegans.de/windows/unattend-generator/?LanguageMode=Interactive&ProcessorArchitecture=amd64&BypassRequirementsCheck=true&BypassNetworkCheck=true&KeepSensitiveFiles=true&ComputerNameMode=Random&CompactOsMode=Never&TimeZoneMode=Implicit&PartitionMode=Interactive&DiskAssertionMode=Skip&WindowsEditionMode=Interactive&InstallFromMode=Automatic&PEMode=Default&UserAccountMode=InteractiveLocal&PasswordExpirationMode=Unlimited&LockoutMode=Default&HideFiles=None&ShowFileExtensions=true&ClassicContextMenu=true&LaunchToThisPC=true&ShowEndTask=true&TaskbarSearch=Hide&TaskbarIconsMode=Default&DisableWidgets=true&LeftTaskbar=true&HideTaskViewButton=true&DisableBingResults=true&StartTilesMode=Empty&StartPinsMode=Empty&DisableWindowsUpdate=true&DisableSac=true&DisableFastStartup=true&DisableSystemRestore=true&EnableLongPaths=true&AllowPowerShellScripts=true&DisableLastAccess=true&PreventAutomaticReboot=true&TurnOffSystemSounds=true&DisableAppSuggestions=true&PreventDeviceEncryption=true&HideEdgeFre=true&DisableEdgeStartupBoost=true&DisablePointerPrecision=true&DisableAutomaticRestartSignOn=true&EffectsMode=Custom&ThumbnailsOrIcon=true&DragFullWindows=true&FontSmoothing=true&DeleteEdgeDesktopIcon=true&DesktopIconsMode=Default&StartFoldersMode=Default&WifiMode=Skip&ExpressSettings=DisableAll&LockKeysMode=Skip&StickyKeysMode=Default&ColorMode=Default&WallpaperMode=Default&LockScreenMode=Default&Remove3DViewer=true&RemoveBingSearch=true&RemoveClipchamp=true&RemoveCopilot=true&RemoveCortana=true&RemoveDevHome=true&RemoveWindowsHello=true&RemoveFamily=true&RemoveFeedbackHub=true&RemoveGameAssist=true&RemoveGetHelp=true&RemoveHandwriting=true&RemoveMailCalendar=true&RemoveMaps=true&RemoveMathInputPanel=true&RemoveMixedReality=true&RemoveZuneVideo=true&RemoveNews=true&RemoveOffice365=true&RemoveOneDrive=true&RemoveOneNote=true&RemoveOneSync=true&RemoveOutlook=true&RemovePaint3D=true&RemovePeople=true&RemovePowerAutomate=true&RemovePowerShellISE=true&RemoveQuickAssist=true&RemoveRecall=true&RemoveRdpClient=true&RemoveSkype=true&RemoveSolitaire=true&RemoveSpeech=true&RemoveStepsRecorder=true&RemoveStickyNotes=true&RemoveTeams=true&RemoveGetStarted=true&RemoveToDo=true&RemoveWallet=true&RemoveWeather=true&RemoveFaxAndScan=true&RemoveWindowsMediaPlayer=true&RemoveWordPad=true&RemoveXboxApps=true&RemoveYourPhone=true&SystemScript0=%3C%21%5BCDATA%5B%3C%23%0D%0A%23+These+script+will+run+in+the+system+context%2C+before+user+accounts+are+created.%0D%0A%5D%5D%3E&SystemScriptType0=Ps1&DefaultUserScript0=%3C%21%5BCDATA%5B%3C%23%0D%0A%23+Use+this+script+to+modify+the+default+user%27s+registry+hive.+For+example%3A%0D%0A%23+Registry%3A%3AHKU%5CDefaultUser%5C...%0D%0A%5D%5D%3E&DefaultUserScriptType0=Ps1&FirstLogonScript0=%3C%21%5BCDATA%5B%3C%23%0D%0A%23+These+script+will+run+when+the+firt+user+logs+on+after+Windows+has+been+installed.%0D%0A%23+The+first+user+to+log+on+is+typically+an+administrator.%0D%0A%5D%5D%3E&FirstLogonScriptType0=Ps1&UserOnceScript0=%3C%21%5BCDATA%5B%3C%23%0D%0A%23+These+script+will+run+whenever+a+user+logs+on+for+the+first+time.%0D%0A%5D%5D%3E&UserOnceScriptType0=Ps1&WdacMode=Skip&AppLockerMode=Skip-->
	<settings pass="offlineServicing"></settings>
	<settings pass="windowsPE">
		<component name="Microsoft-Windows-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<ImageInstall>
				<OSImage>
					<Compact>false</Compact>
				</OSImage>
			</ImageInstall>
			<UserData>
				<ProductKey>
					<Key>00000-00000-00000-00000-00000</Key>
					<WillShowUI>Always</WillShowUI>
				</ProductKey>
				<AcceptEula>true</AcceptEula>
			</UserData>
			<UseConfigurationSet>false</UseConfigurationSet>
			<RunSynchronous>
				<RunSynchronousCommand wcm:action="add">
					<Order>1</Order>
					<Path>reg.exe add "HKLM\SYSTEM\Setup\LabConfig" /v BypassTPMCheck /t REG_DWORD /d 1 /f</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>2</Order>
					<Path>reg.exe add "HKLM\SYSTEM\Setup\LabConfig" /v BypassSecureBootCheck /t REG_DWORD /d 1 /f</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>3</Order>
					<Path>reg.exe add "HKLM\SYSTEM\Setup\LabConfig" /v BypassRAMCheck /t REG_DWORD /d 1 /f</Path>
				</RunSynchronousCommand>
			</RunSynchronous>
		</component>
	</settings>
	<settings pass="generalize"></settings>
	<settings pass="specialize">
		<component name="Microsoft-Windows-Deployment" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<RunSynchronous>
				<RunSynchronousCommand wcm:action="add">
					<Order>1</Order>
					<Path>powershell.exe -WindowStyle "Normal" -NoProfile -Command "$xml = [xml]::new(); $xml.Load('C:\Windows\Panther\unattend.xml'); $sb = [scriptblock]::Create( $xml.unattend.Extensions.ExtractScript ); Invoke-Command -ScriptBlock $sb -ArgumentList $xml;"</Path>
				</RunSynchronousCommand>
                <RunSynchronousCommand wcm:action="add">
					<Order>2</Order>
					<Path>powershell.exe -WindowStyle "Normal" -ExecutionPolicy "Unrestricted" -NoProfile -File "C:\Windows\Setup\Scripts\MySetup.ps1"</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>3</Order>
					<Path>powershell.exe -WindowStyle "Normal" -ExecutionPolicy "Unrestricted" -NoProfile -File "C:\MyMaintenance\Scripts\Specialize.ps1"</Path>
				</RunSynchronousCommand>
			</RunSynchronous>
		</component>
	</settings>
	<settings pass="auditSystem"></settings>
	<settings pass="auditUser"></settings>
	<settings pass="oobeSystem">
		<component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<OOBE>
				<ProtectYourPC>3</ProtectYourPC>
				<HideEULAPage>true</HideEULAPage>
				<HideWirelessSetupInOOBE>true</HideWirelessSetupInOOBE>
				<HideOnlineAccountScreens>true</HideOnlineAccountScreens>
			</OOBE>
		</component>
	</settings>
	<Extensions xmlns="https://schneegans.de/windows/unattend-generator/">
		<ExtractScript>
param(
    [xml] $Document
);

foreach( $file in $Document.unattend.Extensions.File ) {
    $path = [System.Environment]::ExpandEnvironmentVariables( $file.GetAttribute( 'path' ) );
    mkdir -Path( $path | Split-Path -Parent ) -ErrorAction 'SilentlyContinue';
    $encoding = switch( [System.IO.Path]::GetExtension( $path ) ) {
        { $_ -in '.ps1', '.xml' } { [System.Text.Encoding]::UTF8; }
        { $_ -in '.reg', '.vbs', '.js' } { [System.Text.UnicodeEncoding]::new( $false, $true ); }
        default { [System.Text.Encoding]::Default; }
    };
    $bytes = $encoding.GetPreamble() + $encoding.GetBytes( $file.InnerText.Trim() );
    [System.IO.File]::WriteAllBytes( $path, $bytes );
}
		</ExtractScript>
        <File path="C:\Windows\Setup\Scripts\MySetup.ps1">
<![CDATA[
# ============================================================
# MySetup.ps1
# Runs during SPECIALIZE pass
# Creates persistent setup folder structure and
# copies original Setup scripts for post-upgrade reuse.
# ============================================================

$MaintenanceRoot = "C:\MySetup"
$ScriptsDir = Join-Path $MaintenanceRoot "Scripts"
$LogDir          = Join-Path $MaintenanceRoot "Logs"
$StateDir        = Join-Path $MaintenanceRoot "State"

# --- Create folder structure ---
$folders = @(
    $ScriptsDir,
    $LogDir,
    $StateDir
)

foreach ($folder in $folders) {
    if (-not (Test-Path $folder)) {
        New-Item -Path $folder -ItemType Directory -Force | Out-Null
    }
}

# --- Copy original Setup scripts ---
$Source = "C:\Windows\Setup\Scripts"

if (Test-Path $Source) {
    Copy-Item -Path "$Source\*" -Destination $ScriptsDir -Recurse -Force -ErrorAction SilentlyContinue
} else {
    # Optional: log a warning if needed
}

# --- Store current OS build number ---
$Build = (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").CurrentBuildNumber
$Build | Out-File -FilePath (Join-Path $StateDir "LastBuild.txt") -Encoding ASCII -Force
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\Apply-Registry.ps1">
<![CDATA[
function Apply-RegistryEntry {
    param(
        [Parameter(Mandatory)]
        [string]$Path,

        [string]$Operation = "Set",
        [string]$Name,
        [ValidateSet("String","ExpandString","DWord","QWord","Binary","MultiString")]
        [string]$Type,
        $Value,
        [string]$Description = "",

        # For SetByte
        [int]$Offset,
        [byte]$ByteValue,

        # For SetBit
        [int]$BitIndex,
        [int]$BitValue
    )

    try {
        # Ensure key exists for operations that need it
        if ($Operation -notin @("Delete","EnsureKey") -and -not (Test-Path $Path)) {
            New-Item -Path $Path -Force | Out-Null
            Write-Output "[SUCCESS] Created key | Path='$Path' Description='$Description'"
        }

        switch ($Operation) {

            "EnsureKey" {
                if (-not (Test-Path $Path)) {
                    New-Item -Path $Path -Force | Out-Null
                    Write-Output "[SUCCESS] Created key | Path='$Path' Description='$Description'"
                }
                return
            }

            "Set" {
                if (-not $Name) { throw "Operation 'Set' requires a Name" }

                $exists = Get-ItemProperty -Path $Path -Name $Name -ErrorAction SilentlyContinue

                if ($exists) {
                    Set-ItemProperty -Path $Path -Name $Name -Value $Value -Force
                }
                else {
                    New-ItemProperty -Path $Path -Name $Name -Value $Value -PropertyType $Type -Force | Out-Null
                }

                Write-Output "[SUCCESS] $Description | Path='$Path' Name='$Name' Type='$Type' Value='$Value'"
            }

            "SetByte" {
                if (-not $Name) { throw "SetByte requires Name" }
                if ($Offset -lt 0) { throw "Offset must be >= 0" }

                $data = (Get-ItemProperty -Path $Path -Name $Name -ErrorAction Stop).$Name

                if ($data.Length -le $Offset) {
                    throw "Offset $Offset is outside data length $($data.Length)"
                }

                $data[$Offset] = $ByteValue

                Set-ItemProperty -Path $Path -Name $Name -Value $data -Force

                Write-Output "[SUCCESS] $Description | Modified byte $Offset of '$Path\$Name' to 0x{0:X2}" -f $ByteValue
            }

            "SetBit" {
                if (-not $Name) { throw "SetBit requires Name" }
                if ($Offset -lt 0) { throw "Offset must be >= 0" }
                if ($BitIndex -lt 0 -or $BitIndex -gt 7) { throw "BitIndex must be 0-7" }

                $data = (Get-ItemProperty -Path $Path -Name $Name -ErrorAction Stop).$Name

                if ($data.Length -le $Offset) {
                    throw "Offset $Offset is outside data length $($data.Length)"
                }

                $mask = 1 -shl $BitIndex

                if ($BitValue -eq 1) {
                    $data[$Offset] = $data[$Offset] -bor $mask
                }
                else {
                    $data[$Offset] = $data[$Offset] -band (-bnot $mask)
                }

                Set-ItemProperty -Path $Path -Name $Name -Value $data -Force

                Write-Output "[SUCCESS] $Description | Modified bit $BitIndex of byte $Offset in '$Path\$Name'"
            }
            
            "Delete" {
                if ($Name) {
                    if (Test-Path $Path) {
                        $exists = Get-ItemProperty -Path $Path -Name $Name -ErrorAction SilentlyContinue

                        if ($exists -ne $null) {
                            Remove-ItemProperty -Path $Path -Name $Name -Force
                            Write-Output "[SUCCESS] $Description | Deleted value '$Name' from '$Path'"
                        }
                        else {
                            Write-Output "[INFO] $Description | Value '$Name' does not exist at '$Path'"
                        }
                    }
                    else {
                        Write-Output "[INFO] $Description | Key '$Path' does not exist"
                    }
                }
                else {
                    if (Test-Path $Path) {
                        Remove-Item -Path $Path -Recurse -Force
                        Write-Output "[SUCCESS] $Description | Deleted key '$Path'"
                    }
                    else {
                        Write-Output "[INFO] $Description | Key '$Path' does not exist"
                    }
                }

                return
            }

            default {
                throw "Unknown operation '$Operation'"
            }
        }
    }
    catch {
        Write-Output "[ERROR] $Description | Failed at '$Path\$Name' : $($_.Exception.Message)"
    }
}

function Apply-RegistryBatch {
    param(
        [Parameter(Mandatory)]
        [array]$Items
    )

    foreach ($item in $Items) {
        Apply-RegistryEntry @item
    }
}
]]>
        </File>
        <File path="C:\Users\Default\AppData\Local\Microsoft\Windows\Shell\LayoutModification.xml">
<![CDATA[
<LayoutModificationTemplate Version="1" xmlns="http://schemas.microsoft.com/Start/2014/LayoutModification">
	<LayoutOptions StartTileGroupCellWidth="6" />
	<DefaultLayoutOverride>
		<StartLayoutCollection>
			<StartLayout GroupCellWidth="6" xmlns="http://schemas.microsoft.com/Start/2014/FullDefaultLayout" />
		</StartLayoutCollection>
	</DefaultLayoutOverride>
</LayoutModificationTemplate>
]]>
		</File>
        <File path="C:\Windows\Setup\Scripts\Specialize.ps1">
<![CDATA[
. "C:\MySetup\Scripts\Apply-Registry.ps1"

$scripts = @(
    {
        & "C:\MySetup\Scripts\Debloat.ps1"
    };
	{
        reg.exe load "HKU\DefaultUser" "C:\Users\Default\NTUSER.DAT"
		& "C:\MySetup\Scripts\DefaultUser.ps1"
        reg.exe unload "HKU\DefaultUser"
	};
    {
        Apply-Registry -Path "HKU\DefaultUser\Software\Microsoft\Windows\CurrentVersion\RunOnce" `
            -Name "CurrentUser" `
            -Type "String" `
            -Value "powershell.exe -WindowStyle \""Normal\"" -ExecutionPolicy \""Unrestricted\"" -NoProfile -File \""C:\MyMaintenance\Scripts\UserOnce.ps1\"""
    };
);

& {
  [float] $complete = 0;
  [float] $increment = 100 / $scripts.Count;
  foreach( $script in $scripts ) {
    Write-Progress -Activity 'Running scripts to customize your Windows installation. Do not close this window.' -PercentComplete $complete;
    "*** Will now execute command $([char]0xAB){0}$([char]0xBB)." -f $(
      $str = $script.ToString().Trim() -replace '\s+', ' ';
      $max = 100;
      if( $str.Length -le $max ) {
        $str;
      } else {
        $str.Substring( 0, $max - 1 ) + "$([char]0x2026)";
      }
    );
    $start = [datetime]::Now;
    & $script;
    '*** Finished executing command after {0:0} ms.' -f [datetime]::Now.Subtract( $start ).TotalMilliseconds;
    "`r`n" * 3;
    $complete += $increment;
  }
} *>&1 | Out-String -Width 1KB -Stream >> "C:\MySetup\Logs\Specialize.log";
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\DefaultUser.ps1">
<![CDATA[
$scripts = @(
	{
    
	};
);

& {
  [float] $complete = 0;
  [float] $increment = 100 / $scripts.Count;
  foreach( $script in $scripts ) {
    Write-Progress -Activity "Running scripts to modify the default user$([char]0x2019)$([char]0x2019)s registry hive. Do not close this window." -PercentComplete $complete;
    "*** Will now execute command $([char]0xAB){0}$([char]0xBB)." -f $(
      $str = $script.ToString().Trim() -replace '\s+', ' ';
      $max = 100;
      if( $str.Length -le $max ) {
        $str;
      } else {
        $str.Substring( 0, $max - 1 ) + "$([char]0x2026)";
      }
    );
    $start = [datetime]::Now;
    & $script;
    '*** Finished executing command after {0:0} ms.' -f [datetime]::Now.Subtract( $start ).TotalMilliseconds;
    "`r`n" * 3;
    $complete += $increment;
  }
} *>&1 | Out-String -Width 1KB -Stream >> "C:\MySetup\Logs\DefaultUser.log";
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\CurrentUser.ps1">
<![CDATA[
$logsDir = "$env:LOCALAPPDATA\MySetup"
if (-not (Test-Path $logsDir)) {
    New-Item -Path $logsDir -ItemType Directory -Force | Out-Null
}

$scripts = @(
	{
    
	};
);

& {
  [float] $complete = 0;
  [float] $increment = 100 / $scripts.Count;
  foreach( $script in $scripts ) {
    Write-Progress -Activity 'Running scripts to configure this user account. Do not close this window.' -PercentComplete $complete;
    "*** Will now execute command $([char]0xAB){0}$([char]0xBB)." -f $(
      $str = $script.ToString().Trim() -replace '\s+', ' ';
      $max = 100;
      if( $str.Length -le $max ) {
        $str;
      } else {
        $str.Substring( 0, $max - 1 ) + "$([char]0x2026)";
      }
    );
    $start = [datetime]::Now;
    & $script;
    '*** Finished executing command after {0:0} ms.' -f [datetime]::Now.Subtract( $start ).TotalMilliseconds;
    "`r`n" * 3;
    $complete += $increment;
  }
} *>&1 | Out-String -Width 1KB -Stream >> "$logsDir\CurrentUser.log";
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\Debloat.ps1">
<![CDATA[
& "C:\MySetup\Scripts\RemovePackages.ps1"
& "C:\MySetup\Scripts\RemoveCapabilities.ps1"
& "C:\MySetup\Scripts\RemoveFeatures.ps1"
& "C:\MySetup\Scripts\RemoveOneDrive.ps1" >> "C:\MySetup\Logs\RemoveOneDrive.log" 2>&1
& "C:\MySetup\Scripts\RemoveEdge.ps1" >> "C:\MySetup\Logs\RemoveEdge.log" 2>&1
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\RemovePackages.ps1">
<![CDATA[
$selectors = @(
	'Microsoft.Microsoft3DViewer';
	'Microsoft.BingSearch';
	'Clipchamp.Clipchamp';
	'Microsoft.Copilot';
	'Microsoft.549981C3F5F10';
	'Microsoft.Windows.DevHome';
	'MicrosoftCorporationII.MicrosoftFamily';
	'Microsoft.WindowsFeedbackHub';
	'Microsoft.Edge.GameAssist';
	'Microsoft.GetHelp';
	'Microsoft.Getstarted';
	'microsoft.windowscommunicationsapps';
	'Microsoft.WindowsMaps';
	'Microsoft.MixedReality.Portal';
	'Microsoft.BingNews';
	'Microsoft.MicrosoftOfficeHub';
	'Microsoft.Office.OneNote';
	'Microsoft.OutlookForWindows';
	'Microsoft.MSPaint';
	'Microsoft.People';
	'Microsoft.PowerAutomateDesktop';
	'MicrosoftCorporationII.QuickAssist';
	'Microsoft.SkypeApp';
	'Microsoft.MicrosoftSolitaireCollection';
	'Microsoft.MicrosoftStickyNotes';
	'MicrosoftTeams';
	'MSTeams';
	'Microsoft.Todos';
	'Microsoft.Wallet';
	'Microsoft.BingWeather';
	'Microsoft.Xbox.TCUI';
	'Microsoft.XboxApp';
	'Microsoft.XboxGameOverlay';
	'Microsoft.XboxGamingOverlay';
	'Microsoft.XboxIdentityProvider';
	'Microsoft.XboxSpeechToTextOverlay';
	'Microsoft.GamingApp';
	'Microsoft.YourPhone';
	'Microsoft.ZuneVideo';
);
$getCommand = {
  Get-AppxProvisionedPackage -Online;
};
$filterCommand = {
  $_.DisplayName -like "*$selector*";
};
$removeCommand = {
  [CmdletBinding()]
  param(
    [Parameter( Mandatory, ValueFromPipeline )]
    $InputObject
  );
  process {
    $InputObject | Remove-AppxProvisionedPackage -AllUsers -Online -ErrorAction 'Continue';
    
    $PFN = (Get-AppxPackage -Name $InputObject.DisplayName -AllUsers).PackageFamilyName

    if ($PFN) {
        $RegPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore\Deprovisioned\$PFN"
        if (!(Test-Path $RegPath)) {
            # Use | Out-Null to prevent this from being captured by $result.Output
            New-Item -Path $RegPath -Force | Out-Null
        }
    }
  }
};
$type = 'Package';
$logfile = 'C:\MyMaintenance\Logs\RemovePackages.log';
& {
	$installed = & $getCommand;
	foreach( $selector in $selectors ) {
		$result = [ordered] @{
			Selector = $selector;
		};
		$found = $installed | Where-Object -FilterScript $filterCommand;
		if( $found ) {
			$result.Output = $found | & $removeCommand;
			if( $? ) {
				$result.Message = "$type removed.";
			} else {
				$result.Message = "$type not removed.";
				$result.Error = $Error[0];
			}
		} else {
			$result.Message = "$type not installed.";
		}
		$result | ConvertTo-Json -Depth 3 -Compress;
	}
} *>&1 | Out-String -Width 1KB -Stream >> $logfile;
]]>
		</File>
		<File path="C:\Windows\Setup\Scripts\RemoveCapabilities.ps1">
<![CDATA[
$selectors = @(
	'Print.Fax.Scan';
	'Language.Handwriting';
	'MathRecognizer';
	'OneCoreUAP.OneSync';
	'Microsoft.Windows.PowerShell.ISE';
	'App.Support.QuickAssist';
	'Language.Speech';
	'Language.TextToSpeech';
	'App.StepsRecorder';
	'Hello.Face.18967';
	'Hello.Face.Migration.18967';
	'Hello.Face.20134';
	'Media.WindowsMediaPlayer';
	'Microsoft.Windows.WordPad';
);
$getCommand = {
  Get-WindowsCapability -Online | Where-Object -Property 'State' -NotIn -Value @(
    'NotPresent';
    'Removed';
  );
};
$filterCommand = {
  ($_.Name -split '~')[0] -eq $selector;
};
$removeCommand = {
  [CmdletBinding()]
  param(
    [Parameter( Mandatory, ValueFromPipeline )]
    $InputObject
  );
  process {
    $InputObject | Remove-WindowsCapability -Online -ErrorAction 'Continue';
  }
};
$type = 'Capability';
$logfile = 'C:\MyMaintenance\Logs\RemoveCapabilities.log';
& {
	$installed = & $getCommand;
	foreach( $selector in $selectors ) {
		$result = [ordered] @{
			Selector = $selector;
		};
		$found = $installed | Where-Object -FilterScript $filterCommand;
		if( $found ) {
			$result.Output = $found | & $removeCommand;
			if( $? ) {
				$result.Message = "$type removed.";
			} else {
				$result.Message = "$type not removed.";
				$result.Error = $Error[0];
			}
		} else {
			$result.Message = "$type not installed.";
		}
		$result | ConvertTo-Json -Depth 3 -Compress;
	}
} *>&1 | Out-String -Width 1KB -Stream >> $logfile;
]]>
		</File>
		<File path="C:\Windows\Setup\Scripts\RemoveFeatures.ps1">
<![CDATA[
$selectors = @(
	'Microsoft-RemoteDesktopConnection';
	'Recall';
);
$getCommand = {
  Get-WindowsOptionalFeature -Online | Where-Object -Property 'State' -NotIn -Value @(
    'Disabled';
    'DisabledWithPayloadRemoved';
  );
};
$filterCommand = {
  $_.FeatureName -eq $selector;
};
$removeCommand = {
  [CmdletBinding()]
  param(
    [Parameter( Mandatory, ValueFromPipeline )]
    $InputObject
  );
  process {
    $InputObject | Disable-WindowsOptionalFeature -Online -Remove -NoRestart -ErrorAction 'Continue';
  }
};
$type = 'Feature';
$logfile = 'C:\MyMaintenance\Logs\RemoveFeatures.log';
& {
	$installed = & $getCommand;
	foreach( $selector in $selectors ) {
		$result = [ordered] @{
			Selector = $selector;
		};
		$found = $installed | Where-Object -FilterScript $filterCommand;
		if( $found ) {
			$result.Output = $found | & $removeCommand;
			if( $? ) {
				$result.Message = "$type removed.";
			} else {
				$result.Message = "$type not removed.";
				$result.Error = $Error[0];
			}
		} else {
			$result.Message = "$type not installed.";
		}
		$result | ConvertTo-Json -Depth 3 -Compress;
	}
} *>&1 | Out-String -Width 1KB -Stream >> $logfile;
]]>
		</File>
        <File path="C:\Windows\Setup\Scripts\RemoveOneDrive.ps1">
<![CDATA[
<#
  .SYNOPSIS
      Removes Microsoft OneDrive from Windows 10/11 systems.

  .DESCRIPTION
      This script detects and removes Microsoft OneDrive installations including:
      - Registry-based uninstallation using the user's HKU uninstall entry
      - OneDrive files and folders from the current users' AppData folder. (NOTE: Userdata in %USERPROFILE%\OneDrive is preserved)
      - System-wide OneDrive installation files
      - OneDrive scheduled tasks
      - Start Menu shortcuts
      - Default user profile configuration to prevent auto-installation

      This script is designed to run in any context: user sessions, SYSTEM account, or scheduled tasks.

  .NOTES
      Source: https://github.com/memstechtips/Winhance

      Requirements:
      - Windows 10/11
      - Administrator privileges (script will auto-elevate)
      - PowerShell 5.1 or higher
      
      Refined by additional guards to prevent reinstallation
#>

# Check if script is running as Administrator
If (!([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]"Administrator")) {
    Try {
        Start-Process PowerShell.exe -ArgumentList ("-NoProfile -ExecutionPolicy Bypass -File `"{0}`"" -f $PSCommandPath) -Verb RunAs
        Exit
    }
    Catch {
        Write-Output "Failed to run as Administrator. Please rerun with elevated privileges."
        Exit
    }
}

Write-Output "Starting OneDrive removal process"

# Get the interactive user when running as SYSTEM (not needed for regular user execution)
function Get-TargetUser {
    Write-Output "Get-TargetUser: Starting user detection"

    # Try interactive user first
    try {
        $user = Get-WmiObject Win32_ComputerSystem | Select-Object -ExpandProperty UserName
        Write-Output "Get-TargetUser: Win32_ComputerSystem returned: '$user'"
        if ($user -and $user -ne "NT AUTHORITY\SYSTEM") {
            $username = $user.Split('\')[1]
            Write-Output "Get-TargetUser: Extracted username: '$username'"
            return $username
        }
        Write-Output "Get-TargetUser: User is null or SYSTEM, trying fallback method"
    }
    catch {
        Write-Output "Get-TargetUser: Win32_ComputerSystem failed: $($_.Exception.Message)"
    }

    # Fallback: find user running explorer.exe
    try {
        $explorer = Get-Process explorer -ErrorAction SilentlyContinue | Select-Object -First 1
        Write-Output "Get-TargetUser: Explorer process found: $($explorer -ne $null)"
        if ($explorer) {
            $owner = $explorer.GetOwner()
            Write-Output "Get-TargetUser: Explorer owner: Domain='$($owner.Domain)', User='$($owner.User)'"
            return $owner.User
        }
        Write-Output "Get-TargetUser: No explorer process found"
    }
    catch {
        Write-Output "Get-TargetUser: Explorer method failed: $($_.Exception.Message)"
    }

    Write-Output "Get-TargetUser: No user found, returning null"
    return $null
}

# Get the user's SID for registry access
function Get-UserSID {
    param($Username)
    try {
        $user = New-Object System.Security.Principal.NTAccount($Username)
        return $user.Translate([System.Security.Principal.SecurityIdentifier]).Value
    }
    catch {
        Write-Output "Get-UserSID: Failed for user '$Username': $($_.Exception.Message)"
        return $null
    }
}

# Determine user profile to check
Write-Output "Current environment: USERNAME='$env:USERNAME', USERPROFILE='$env:USERPROFILE'"

if ($env:USERNAME -eq "SYSTEM" -or $env:USERNAME -like "*$" -or $env:USERPROFILE -like "*\system32\config\systemprofile") {
    Write-Output "Running as SYSTEM, attempting to detect target user"
    $targetUser = Get-TargetUser
    if ($targetUser) {
        $userProfilePath = "C:\Users\$targetUser"
        Write-Output "Running as SYSTEM, targeting user: '$targetUser', profile path: '$userProfilePath'"
    } else {
        Write-Output "Running as SYSTEM but no target user found"
        $userProfilePath = $null
    }
} else {
    $targetUser = $env:USERNAME
    $userProfilePath = $env:USERPROFILE
    Write-Output "Running as regular user: '$targetUser', profile path: '$userProfilePath'"
}

# Step 1: Check registry for OneDrive installation and run uninstaller if found
if ($targetUser) {
    $userSID = Get-UserSID -Username $targetUser
    if ($userSID) {
        Write-Output "User SID for '$targetUser': $userSID"

        # Check if OneDrive uninstall entry exists in user's registry
        $uninstallKey = "HKU\$userSID\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\OneDriveSetup.exe"
        Write-Output "Checking uninstall registry key: $uninstallKey"

        try {
            # Query the uninstall string
            $uninstallString = reg.exe query $uninstallKey /v UninstallString 2>$null
            if ($LASTEXITCODE -eq 0 -and $uninstallString) {
                # Extract the actual command from reg output
                $uninstallLine = $uninstallString | Where-Object { $_ -match "UninstallString" } | Select-Object -First 1
                if ($uninstallLine -match "REG_SZ\s+(.+)") {
                    $uninstallCommand = $matches[1].Trim()
                    Write-Output "Found uninstall command: $uninstallCommand"

                    # Stop OneDrive processes
                    Write-Output "Stopping OneDrive processes"
                    Stop-Process -Name "*OneDrive*" -Force -ErrorAction SilentlyContinue | Out-Null

                    # Execute the uninstall command directly
                    Write-Output "Executing registry-based uninstaller"

                    if ($uninstallCommand -match '^"([^"]+)"(.*)') {
                        $exePath = $matches[1]
                        $arguments = $matches[2].Trim()
                        Write-Output "Command: '$exePath' Arguments: '$arguments'"
                        Start-Process -FilePath $exePath -ArgumentList $arguments -WindowStyle Hidden -Wait | Out-Null
                    } else {
                        # Fallback: execute as-is
                        Write-Output "Command: '$uninstallCommand'"
                        cmd.exe /c $uninstallCommand 2>&1 | Out-Null
                    }
                    Write-Output "Registry-based uninstaller completed"
                } else {
                    Write-Output "Could not parse UninstallString from registry output"
                }
            } else {
                Write-Output "OneDrive uninstall registry key not found or empty"
            }
        }
        catch {
            Write-Output "Registry-based uninstall failed: $($_.Exception.Message)"
        }
    } else {
        Write-Output "Could not get user SID for '$targetUser'"
    }
} else {
    Write-Output "No target user found for uninstall check"
}

# Step 3: Always run cleanup tasks
Write-Output "Starting cleanup tasks"

# 3.1: Delete OneDrive registry key
if ($targetUser -and $userSID) {
    $uninstallKey = "HKU\$userSID\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\OneDriveSetup.exe"
    Write-Output "Deleting OneDrive uninstall registry key: $uninstallKey"
    reg.exe delete $uninstallKey /f 2>&1 | Out-Null
    if ($LASTEXITCODE -eq 0) {
        Write-Output "Registry key deleted successfully"
    } else {
        Write-Output "Registry key not found or already deleted"
    }
}

# 3.2: Delete OneDrive AppData folder
if ($userProfilePath) {
    $currentUserOneDrivePath = Join-Path $userProfilePath "AppData\Local\Microsoft\OneDrive"
    Write-Output "Checking OneDrive AppData folder: $currentUserOneDrivePath"

    if (Test-Path $currentUserOneDrivePath) {
        Write-Output "Removing OneDrive folder for user: $targetUser"
        try {
            takeown /f $currentUserOneDrivePath /r /d y 2>&1 | Out-Null
            icacls $currentUserOneDrivePath /grant "${env:USERNAME}:F" /t 2>&1 | Out-Null
            Remove-Item $currentUserOneDrivePath -Recurse -Force -ErrorAction SilentlyContinue
            Write-Output "OneDrive folder removed for user: $targetUser"
        }
        catch {
            Write-Output "Failed to remove OneDrive folder for user: $targetUser - $($_.Exception.Message)"
        }
    } else {
        Write-Output "OneDrive AppData folder not found"
    }
}

# 3.3: Delete OneDrive Start Menu entry
if ($userProfilePath) {
    $startMenuPath = Join-Path $userProfilePath "AppData\Roaming\Microsoft\Windows\Start Menu\Programs\OneDrive.lnk"
    Write-Output "Checking OneDrive Start Menu shortcut: $startMenuPath"

    if (Test-Path $startMenuPath) {
        Remove-Item $startMenuPath -Force -ErrorAction SilentlyContinue
        Write-Output "OneDrive Start Menu shortcut removed"
    } else {
        Write-Output "OneDrive Start Menu shortcut not found"
    }
}

# 3.4: Delete system OneDrive files
$systemPaths = @(
    "C:\Windows\System32\OneDriveSetup.exe",
    "C:\Windows\SysWOW64\OneDriveSetup.exe",
    "C:\Program Files\Microsoft OneDrive"
)

foreach ($path in $systemPaths) {
    Write-Output "Checking system path: $path"
    if (Test-Path $path) {
        Write-Output "Removing: $path"
        try {
            takeown /f $path /r /d y 2>&1 | Out-Null
            icacls $path /grant "${env:USERNAME}:F" /t 2>&1 | Out-Null
            Remove-Item $path -Recurse -Force -ErrorAction SilentlyContinue
            Write-Output "Successfully removed: $path"
        }
        catch {
            Write-Output "Failed to remove: $path - $($_.Exception.Message)"
        }
    } else {
        Write-Output "Path not found: $path"
    }
}

# 3.5: Delete OneDrive scheduled tasks
Write-Output "Checking for OneDrive scheduled tasks"
try {
    $oneDriveTasks = Get-ScheduledTask -TaskName "*OneDrive*" -ErrorAction SilentlyContinue
    if ($oneDriveTasks) {
        foreach ($task in $oneDriveTasks) {
            # Skip the OneDriveRemoval task
            if ($task.TaskName -eq "OneDriveRemoval") {
                Write-Output "Skipping OneDriveRemoval task: $($task.TaskName)"
                continue
            }
            
            Write-Output "Found OneDrive scheduled task: $($task.TaskName) - State: $($task.State)"
            try {
                Unregister-ScheduledTask -TaskName $task.TaskName -TaskPath $task.TaskPath -Confirm:$false -ErrorAction SilentlyContinue
                Write-Output "Deleted scheduled task: $($task.TaskName)"
            }
            catch {
                Write-Output "Failed to delete scheduled task: $($task.TaskName) - $($_.Exception.Message)"
            }
        }
    } else {
        Write-Output "No OneDrive scheduled tasks found"
    }
}
catch {
    Write-Output "Failed to check scheduled tasks: $($_.Exception.Message)"
}

# 3.6: Configure default user registry to prevent OneDrive auto-install
$markerKey = "HKLM\SOFTWARE\Winhance\OneDriveRemoval"
$markerValue = reg.exe query $markerKey /v "DefaultUserConfigured" 2>$null

if ($LASTEXITCODE -eq 0) {
    Write-Output "Default user already configured on this machine, skipping this step."
} else {
    Write-Output "Configuring registry to prevent OneDrive auto-install for new users"
    reg.exe Load HKEY_USERS\Default "C:\Users\Default\NTUSER.DAT" 2>&1 | Out-Null
    reg.exe delete "HKU\Default\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "OneDriveSetup" /f 2>&1 | Out-Null
    reg.exe add "HKU\Default\SOFTWARE\Microsoft\OneDrive" /v "EnableTHDFFeatures" /t REG_DWORD /d "0" /f 2>&1 | Out-Null
    # Close regedit in case it is running so we can unload the hive
    Stop-Process -Name "regedit" -Force -ErrorAction SilentlyContinue
    reg.exe Unload HKEY_USERS\Default 2>&1 | Out-Null

    # Create marker to indicate this machine has been configured
    reg.exe add $markerKey /v "DefaultUserConfigured" /t REG_SZ /d "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" /f 2>&1 | Out-Null
    Write-Output "Default user configuration completed and marked"
}

# 1. Create the Appx Deprovisioned Marker
$OneDrivePFN = "Microsoft.OneDrive_8wekyb3d8bbwe"
$DeprovisionPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore\Deprovisioned\$OneDrivePFN"
if (!(Test-Path $DeprovisionPath)) { New-Item -Path $DeprovisionPath -Force }

# 2. Block the legacy system-wide installer via Policy
# This is the "Gold Standard" for 2025 to stop the .exe from returning
$PolicyPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\OneDrive"
if (!(Test-Path $PolicyPath)) { New-Item -Path $PolicyPath -Force }
New-ItemProperty -Path $PolicyPath -Name "DisableFileSyncNGSC" -Value 1 -PropertyType DWORD -Force

Write-Output "Done."
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\RemoveEdge.ps1">
<![CDATA[

<#
  .SYNOPSIS
      Removes Microsoft Edge (Legacy and Chromium versions) from Windows 10/11 systems.

  .DESCRIPTION
      This script detects and removes Microsoft Edge installations including:
      - Legacy UWP Edge (pre-Chromium)
      - Chromium-based Edge (current version)
      - EdgeUpdate components
      - EdgeWebView2 is NOT removed

      This script is designed to run in any context: user sessions, SYSTEM account, or scheduled tasks.

  .NOTES
      Source: https://github.com/memstechtips/Winhance

      Requirements:
      - Windows 10/11
      - Administrator privileges (script will auto-elevate)
      - PowerShell 5.1 or higher

      Credits:
      - Legacy Edge removal based on work by ishad0w: https://gist.github.com/ishad0w/d25ca52eb04dbefba8087a344a69c79c
      - Chromium Edge removal based on work by FR33THY: https://github.com/FR33THYFR33THY/Ultimate-Windows-Optimization-Guide/blob/main/6%20Windows/14%20Edge.ps1
      - Edge protocol redirect based on OpenWebSearch by AveYo: https://github.com/AveYo/fox/blob/main/OpenWebSearch.cmd
      
      Minor refactoring for embedding in Schneegans's generated autounattend.xml
#>

# Check if script is running as Administrator
If (!([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]"Administrator")) {
    Try {
        Start-Process PowerShell.exe -ArgumentList ("-NoProfile -ExecutionPolicy Bypass -File `"{0}`"" -f $PSCommandPath) -Verb RunAs
        Exit
    }
    Catch {
        Write-Output "Failed to run as Administrator. Please rerun with elevated privileges."
        Exit
    }
}

# Helper function to get Legacy Edge packages
function Get-LegacyEdgePackages {
    $legacyRegPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\Packages"
    return Get-ChildItem -Path $legacyRegPath -Name -ErrorAction SilentlyContinue | Where-Object { $_ -match "Microsoft-Windows-Internet-Browser-Package" -and $_ -match "~~" }
}

# Function to test if Legacy Edge is installed
function Test-LegacyEdgeInstalled {
    $packages = Get-LegacyEdgePackages

    if ($packages) {
        foreach ($package in $packages) {
            $packageInfo = & dism /online /Get-PackageInfo /PackageName:$package 2>$null
            if ($packageInfo -match "State.*Installed") {
                return $true
            }
        }
    }
    return $false
}

# Function to test if Chromium Edge is installed
function Test-ChromiumEdgeInstalled {
    # Check folders first (fastest)
    $edgeFolders = @("Edge", "EdgeCore", "EdgeUpdate")
    $programFiles = @($env:ProgramFiles, ${env:ProgramFiles(x86)})

    foreach ($pf in $programFiles) {
        foreach ($folder in $edgeFolders) {
            if (Test-Path "$pf\Microsoft\$folder") {
                return $true
            }
        }
    }

    # Fallback: Check installed programs
    try {
        $edgeApp = Get-WmiObject -Class Win32_InstalledStoreProgram -Filter "Name like '%Microsoft.MicrosoftEdge.Stable%'" -ErrorAction SilentlyContinue
        return $edgeApp -ne $null
    } catch {
        return $false
    }
}

# Function to stop Edge-related processes
function Stop-EdgeProcesses {
    Write-Output "Stopping Edge-related processes and services"
    $stop = "MicrosoftEdgeUpdate", "OneDrive", "WidgetService", "Widgets", "msedge", "Resume", "CrossDeviceResume", "msedgewebview2"
    $stop | ForEach-Object {
        $processCount = (Get-Process -Name $_ -ErrorAction SilentlyContinue).Count
        if ($processCount -gt 0) {
            Stop-Process -Name $_ -Force -ErrorAction SilentlyContinue
            Write-Output "Stopped $processCount instance(s) of $_"
        }
    }
}

# Function to remove Legacy Edge
function Remove-LegacyEdge {
    Write-Output "Starting Legacy Edge/UWP Edge removal process"
    # Query registry for Edge Legacy package
    $packages = Get-LegacyEdgePackages
    $edgeLegacyPackageVersion = $packages | Select-Object -First 1
    $packagePath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\Packages\$edgeLegacyPackageVersion"
    # Set registry visibility
    Set-ItemProperty -Path $packagePath -Name "Visibility" -Value 1 -Type DWord -Force -ErrorAction SilentlyContinue
    # Remove owners registry entries
    $ownersPath = "$packagePath\Owners"
    if (Test-Path $ownersPath) { Remove-Item -Path $ownersPath -Recurse -Force -ErrorAction SilentlyContinue }
    Write-Output "Removing Legacy Edge package via DISM (with 30-second timeout)"
    $dismProcess = Start-Process -FilePath "dism.exe" -ArgumentList "/online", "/Remove-Package", "/PackageName:$edgeLegacyPackageVersion", "/NoRestart" -NoNewWindow -PassThru

    if ($dismProcess -and $dismProcess.WaitForExit(30000)) {
        Write-Output "DISM completed successfully"
    } elseif ($dismProcess) {
        Write-Output "DISM timed out after 30 seconds, killing process and retrying once"
        $dismProcess.Kill()
        Start-Sleep 2

        # Retry once
        Write-Output "Retrying DISM command"
        $retryProcess = Start-Process -FilePath "dism.exe" -ArgumentList "/online", "/Remove-Package", "/PackageName:$edgeLegacyPackageVersion", "/NoRestart" -NoNewWindow -PassThru

        if ($retryProcess -and $retryProcess.WaitForExit(30000)) {
            Write-Output "DISM retry completed successfully"
        } elseif ($retryProcess) {
            Write-Output "DISM retry also timed out, continuing with script"
            $retryProcess.Kill()
        } else {
            Write-Output "DISM retry failed to start, continuing with script"
        }
    } else {
        Write-Output "DISM failed to start, continuing with script"
    }
    # Remove Legacy UWP Edge package
    Write-Output "Removing Legacy UWP Edge package"
    Get-AppxPackage Microsoft.MicrosoftEdge | Remove-AppxPackage -ErrorAction SilentlyContinue | Out-Null
    Write-Output "Legacy Edge/UWP Edge removal process completed"
}

# Function to remove Edge shortcuts
function Remove-EdgeShortcuts {
    Write-Output "Starting Edge shortcuts cleanup"

    # Get ALL user profiles (no exclusions)
    $userProfiles = Get-ChildItem -Path "C:\Users" -Directory | Where-Object {
        (Test-Path -Path "$($_.FullName)\NTUSER.DAT")
    }

    # Build all shortcut paths to check
    $shortcutPaths = @()

    # Add user-specific paths (now includes Public, Default, etc.)
    foreach ($profile in $userProfiles) {
        $shortcutPaths += @(
            "$($profile.FullName)\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\Microsoft Edge.lnk",
            "$($profile.FullName)\Desktop\Microsoft Edge.lnk",
            "$($profile.FullName)\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\Microsoft Edge.lnk",
            "$($profile.FullName)\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\Tombstones\Microsoft Edge.lnk",
            "$($profile.FullName)\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Microsoft Edge.lnk"
        )
    }

    # Add the single ProgramData path
    $shortcutPaths += "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Microsoft Edge.lnk"

    # Remove all shortcuts in one loop
    $removedCount = 0
    foreach ($path in $shortcutPaths) {
        if (Test-Path -Path $path -PathType Leaf) {
            Remove-Item -Path $path -Force -ErrorAction SilentlyContinue
            $removedCount++
        }
    }

    Write-Output "Removed $removedCount Edge shortcut(s)"
}

function Install-EdgeProtocolRedirect {
    Write-Output "Checking if Edge protocol redirect is needed"

    $ifeoCheck = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ie_to_edge_stub.exe\0"
    if (Test-Path $ifeoCheck) {
        $debugger = (Get-ItemProperty -Path $ifeoCheck -Name "Debugger" -ErrorAction SilentlyContinue).Debugger
        if ($debugger -like "*OpenWebSearch*") {
            Write-Output "Edge protocol redirect already installed"
            return
        }
    }

    Write-Output "Installing Edge protocol redirect using OpenWebSearch"
    $scriptsDir = "C:\MyMaintenance\Scripts\OpenWebSearch"
    New-Item -ItemType Directory -Path $scriptsDir -Force -ErrorAction SilentlyContinue | Out-Null

    $stubTargetPath = "$scriptsDir\ie_to_edge_stub.exe"
    if (!(Test-Path $stubTargetPath)) {
        Write-Output "Warning: ie_to_edge_stub.exe not found at $stubTargetPath (should have been copied before Edge removal)"
        return
    }

    $openWebSearchContent = @"
@title OpenWebSearch 2023 & echo off
for /f %%E in ('"prompt `$E`$S& for %%e in (1) do rem"') do echo;%%E[2t 2>nul

call :reg_var "HKCU\SOFTWARE\Microsoft\Windows\Shell\Associations\UrlAssociations\https\UserChoice" ProgID ProgID
if /i "%ProgID%" equ "MSEdgeHTM" exit /b

call :reg_var "HKCR\%ProgID%\shell\open\command" "" Browser
set Choice=& for %%. in (%Browser%) do if not defined Choice set "Choice=%%~."

call :reg_var "HKCR\MSEdgeMHT\shell\open\command" "" FallBack
set "Edge=" & for %%. in (%FallBack%) do if not defined Edge set "Edge=%%~."
set "URI=" & set "URL=" & set "NOOP=" & set "PassTrough=%Edge:msedge=edge%"

set "CLI=%CMDCMDLINE:"=````%"
if defined CLI set "CLI=%CLI:*ie_to_edge_stub.exe```` =%"
if defined CLI set "CLI=%CLI:*ie_to_edge_stub.exe =%"
if defined CLI set "CLI=%CLI:*msedge.exe```` =%"
if defined CLI set "CLI=%CLI:*msedge.exe =%"
set "FIX=%CLI:~-1%"
if defined CLI if "%FIX%"==" " set "CLI=%CLI:~0,-1%"
if defined CLI set "RED=%CLI:microsoft-edge=%"
if defined CLI set "URL=%CLI:http=%"
if defined CLI set "ARG=%CLI:````="%"

if "%CLI%" equ "%RED%" (set NOOP=1) else if "%CLI%" equ "%URL%" (set NOOP=1)
if defined NOOP if not exist "%PassTrough%" echo;@mklink /h "%PassTrough%" "%Edge%" >"%Temp%\OpenWebSearchRepair.cmd"
if defined NOOP if not exist "%PassTrough%" schtasks /run /tn OpenWebSearchRepair 2>nul >nul
if defined NOOP if not exist "%PassTrough%" timeout /t 3 >nul
if defined NOOP if exist "%PassTrough%" start "" "%PassTrough%" %ARG%
if defined NOOP exit /b

set "URL=%CLI:*microsoft-edge=%"
set "URL=http%URL:*http=%"
set "FIX=%URL:~-2%"
if defined URL if "%FIX%"=="````" set "URL=%URL:~0,-2%"
call :dec_url
start "" "%Choice%" "%URL%"
exit

:reg_var
set {var}=& set {reg}=reg query "%~1" /v %2 /z /se "," /f /e& if %2=="" set {reg}=reg query "%~1" /ve /z /se "," /f /e
for /f "skip=2 tokens=* delims=" %%V in ('%{reg}% %4 %5 %6 %7 %8 %9 2^>nul') do if not defined {var} set "{var}=%%V"
if not defined {var} (set {reg}=& set "%~3="& exit /b) else if %2=="" set "{var}=%{var}:*)    =%"
if not defined {var} (set {reg}=& set "%~3="& exit /b) else set {reg}=& set "%~3=%{var}:*)    =%"& set {var}=& exit /b

:dec_url
set ".=%URL:!=}%" & setlocal enabledelayedexpansion
set ".=!.:%%={!" &set ".=!.:{3A=:!" &set ".=!.:{2F=/!" &set ".=!.:{3F=?!" &set ".=!.:{23=#!" &set ".=!.:{5B=[!" &set ".=!.:{5D=]!"
set ".=!.:{40=@!"&set ".=!.:{21=}!" &set ".=!.:{24=`$!" &set ".=!.:{26=&!" &set ".=!.:{27='!" &set ".=!.:{28=(!" &set ".=!.:{29=)!"
set ".=!.:{2A=*!"&set ".=!.:{2B=+!" &set ".=!.:{2C=,!" &set ".=!.:{3B=;!" &set ".=!.:{3D==!" &set ".=!.:{25=%%!"&set ".=!.:{20= !"
set ".=!.:{=%%!" & endlocal& set "URL=%.:}=!%" & exit /b
"@

    $openWebSearchPath = "$scriptsDir\OpenWebSearch.cmd"
    $openWebSearchContent | Out-File -FilePath $openWebSearchPath -Encoding ASCII -Force
    Write-Output "Created OpenWebSearch.cmd at $openWebSearchPath"

    $msedgePath = "${env:ProgramFiles(x86)}\Microsoft\Edge\Application\msedge.exe"
    $edgePath = "${env:ProgramFiles(x86)}\Microsoft\Edge\Application\edge.exe"
    if ((Test-Path $msedgePath) -and !(Test-Path $edgePath)) {
        cmd /c mklink /h "$edgePath" "$msedgePath" 2>&1 | Out-Null
        Write-Output "Created edge.exe hardlink at $edgePath"
    }

    $buildNumber = [Environment]::OSVersion.Version.Build
    $conhostFlags = if ($buildNumber -gt 25179) { "--width 1 --height 1" } else { "--headless" }
    $conhostDebugger = "$env:SystemRoot\system32\conhost.exe $conhostFlags $scriptsDir\OpenWebSearch.cmd"

    Write-Output "Configuring registry entries for Edge protocol redirect"
    reg.exe add "HKCR\microsoft-edge" /f /ve /d "URL:microsoft-edge" 2>&1 | Out-Null
    reg.exe add "HKCR\microsoft-edge" /f /v "URL Protocol" /d `"`" 2>&1 | Out-Null
    reg.exe add "HKCR\microsoft-edge" /f /v "NoOpenWith" /d `"`" 2>&1 | Out-Null
    reg.exe add "HKCR\microsoft-edge\shell\open\command" /f /ve /d "$stubTargetPath %1" 2>&1 | Out-Null
    reg.exe add "HKCR\MSEdgeHTM" /f /v "NoOpenWith" /d `"`" 2>&1 | Out-Null
    reg.exe add "HKCR\MSEdgeHTM\shell\open\command" /f /ve /d "$stubTargetPath %1" 2>&1 | Out-Null
    reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ie_to_edge_stub.exe" /f /v UseFilter /d 1 /t reg_dword 2>&1 | Out-Null
    reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ie_to_edge_stub.exe\0" /f /v FilterFullPath /d "$stubTargetPath" 2>&1 | Out-Null
    reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ie_to_edge_stub.exe\0" /f /v Debugger /d "$conhostDebugger" 2>&1 | Out-Null
    reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\msedge.exe" /f /v UseFilter /d 1 /t reg_dword 2>&1 | Out-Null
    reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\msedge.exe\0" /f /v FilterFullPath /d "$msedgePath" 2>&1 | Out-Null
    reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\msedge.exe\0" /f /v Debugger /d "$conhostDebugger" 2>&1 | Out-Null
    Write-Output "Registry configuration completed"

    $repairScriptPath = "$scriptsDir\OpenWebSearchRepair.cmd"
    $repairScriptContent = "@echo off`r`nmklink /h ""$edgePath"" ""$msedgePath"""
    $repairScriptContent | Out-File -FilePath $repairScriptPath -Encoding ASCII -Force
    Write-Output "Created repair script at $repairScriptPath"

    Write-Output "Creating OpenWebSearchRepair scheduled task"
    try {
        $taskAction = New-ScheduledTaskAction -Execute $repairScriptPath
        $taskTrigger = New-ScheduledTaskTrigger -Once -At (Get-Date).Date
        $taskSettings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
        $taskPrincipal = New-ScheduledTaskPrincipal -UserId "S-1-5-18" -LogonType ServiceAccount -RunLevel Highest
        Register-ScheduledTask -TaskName 'OpenWebSearchRepair' -Action $taskAction -Trigger $taskTrigger -Settings $taskSettings -Principal $taskPrincipal -Force | Out-Null
        Write-Output "OpenWebSearchRepair scheduled task created"
    } catch {
        Write-Output "Failed to create OpenWebSearchRepair scheduled task: $($_.Exception.Message)"
    }
}

# Function to remove Chromium Edge and EdgeUpdate
function Remove-ChromiumEdge {
    # Remove Chromium Edge
    Write-Output "Starting Edge Chromium uninstallation process"
    # Folder and file to allow uninstall of Edge Chromium Browser
    Write-Output "Creating temporary directory for Edge uninstallation"
    $edgePath = "$env:SystemRoot\SystemApps\Microsoft.MicrosoftEdge_8wekyb3d8bbwe"
    New-Item -Path $edgePath -ItemType Directory -ErrorAction SilentlyContinue | Out-Null
    New-Item -Path $edgePath -ItemType File -Name "MicrosoftEdge.exe" -ErrorAction SilentlyContinue | Out-Null
    # Get Edge Uninstall Strings for Enterprise MSI version or normal version (they require different handling)
    Write-Output "Searching for Edge uninstall strings in registry"
    $uninstallKeys = Get-ChildItem "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
    $edgeUninstallCount = 0
    foreach ($key in $uninstallKeys) {
        $displayName = (Get-ItemProperty $key.PSPath -ErrorAction SilentlyContinue).DisplayName
        if ($displayName -like "*Microsoft Edge*") {
            $uninstallString = (Get-ItemProperty $key.PSPath).UninstallString
            if ($uninstallString) {
                $edgeUninstallCount++
                if ($uninstallString -like "*msiexec*") {
                    # Uninstalls Enterprise MSI version
                    Write-Output "Executing MSI uninstaller for Edge"
                    Start-Process cmd.exe "/c $uninstallString /quiet" -WindowStyle Hidden -Wait | Out-Null
                } else {
                    # Uninstalls normal version
                    Write-Output "Executing standard uninstaller for Edge"
                    Start-Process cmd.exe "/c $uninstallString --force-uninstall --silent" -WindowStyle Hidden -Wait | Out-Null
                }
            }
        }
    }
    if ($edgeUninstallCount -eq 0) {
        Write-Output "No Edge uninstall entries found in registry"
    } else {
        Write-Output "Executed $edgeUninstallCount Edge uninstaller(s)"
    }
    # Remove UWP Edge Chromium package
    Write-Output "Removing UWP Edge Chromium package"
    Get-AppxPackage *Microsoft.MicrosoftEdge.Stable* | Remove-AppxPackage -ErrorAction SilentlyContinue | Out-Null
    # Cleanup: Remove folder and file we created earlier
    Write-Output "Cleaning up temporary Edge directory"
    Remove-Item -Recurse -Force $edgePath -ErrorAction SilentlyContinue | Out-Null
    Write-Output "Edge Chromium uninstallation process completed"

    # Remove EdgeUpdate
    Write-Output "Starting EdgeUpdate removal process"
    # Find EdgeUpdate executables
    Write-Output "Searching for EdgeUpdate executables"
    $edgeupdate = @()
    $searchPaths = @("LocalApplicationData", "ProgramFilesX86", "ProgramFiles")
    foreach ($pathType in $searchPaths) {
        $folder = [Environment]::GetFolderPath($pathType)
        $searchPattern = "$folder\Microsoft\EdgeUpdate\*.*.*.*\MicrosoftEdgeUpdate.exe"
        $foundFiles = Get-ChildItem $searchPattern -Recurse -ErrorAction SilentlyContinue
        if ($foundFiles) {
            $edgeupdate += $foundFiles.FullName
        }
    }
    if ($edgeupdate.Count -gt 0) {
        Write-Output "Found $($edgeupdate.Count) EdgeUpdate executable(s)"
    } else {
        Write-Output "No EdgeUpdate executables found"
    }
    # Backup ClientState registry if it exists (important, or else webview won't work)
    $backupRegFile = "$env:TEMP\EdgeUpdate_ClientState_Backup_$(Get-Date -Format 'yyyyMMdd_HHmmss').reg"
    $clientStatePath = "HKLM:\SOFTWARE\WOW6432Node\Microsoft\EdgeUpdate\ClientState"
    if (Test-Path $clientStatePath) {
        Write-Output "Backing up EdgeUpdate ClientState registry"
        cmd /c "reg export `"HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\EdgeUpdate\ClientState`" `"$backupRegFile`" /y" 2>$null
        if (Test-Path $backupRegFile) {
            Write-Output "Successfully created registry backup at $backupRegFile"
        } else {
            Write-Output "Warning: Failed to create registry backup"
        }
    } else {
        Write-Output "No EdgeUpdate ClientState registry found to backup"
    }
    # Clean registry entries
    Write-Output "Removing EdgeUpdate registry entries"
    $registryPaths = @(
        "HKLM:\SOFTWARE", "HKLM:\SOFTWARE\Policies", "HKLM:\SOFTWARE\WOW6432Node", "HKLM:\SOFTWARE\WOW6432Node\Policies"
    )
    $removedRegCount = 0
    foreach ($location in $registryPaths) {
        $regPath = "$location\Microsoft\EdgeUpdate"
        if (Test-Path $regPath) {
            Remove-Item $regPath -Recurse -Force -ErrorAction SilentlyContinue
            $removedRegCount++
        }
    }
    Write-Output "Removed EdgeUpdate registry entries from $removedRegCount location(s)"
    # Uninstall EdgeUpdate executables
    Write-Output "Processing EdgeUpdate uninstallation"
    foreach ($path in $edgeupdate) {
        if (Test-Path $path) {
            # Unregister service
            Write-Output "Unregistering EdgeUpdate service from $path"
            Start-Process -FilePath $path -ArgumentList "/unregsvc" -Wait -WindowStyle Hidden -ErrorAction SilentlyContinue
            # Wait for processes to finish
            $waitCount = 0
            do {
                Start-Sleep 3
                $runningProcesses = Get-Process -Name "setup", "MicrosoftEdge*" -ErrorAction SilentlyContinue | Where-Object { $_.Path -like "*\Microsoft\Edge*" }
            } while ($runningProcesses -and $waitCount++ -lt 20)
            # Run uninstall if file still exists
            if (Test-Path $path) {
                Write-Output "Running EdgeUpdate uninstaller from $path"
                Start-Process -FilePath $path -ArgumentList "/uninstall" -Wait -WindowStyle Hidden -ErrorAction SilentlyContinue
            }
        }
    }
    # Restore ClientState backup
    if ((Test-Path $backupRegFile)) {
        Write-Output "Restoring EdgeUpdate ClientState registry from backup"
        cmd /c "reg import `"$backupRegFile`"" 2>$null
        Remove-Item $backupRegFile -ErrorAction SilentlyContinue
        Write-Output "Registry restore completed and backup file cleaned up"
    } else {
        Write-Output "No registry backup file found to restore"
    }
    Write-Output "EdgeUpdate removal process completed"
}

Write-Output "Starting Edge removal process. See $logFile for details."

# Check for Edge installations first
Write-Output "Checking for Edge installations..."

$legacyInstalled = Test-LegacyEdgeInstalled
$chromiumInstalled = Test-ChromiumEdgeInstalled

if (-not $legacyInstalled -and -not $chromiumInstalled) {
    Write-Output "No Edge installations detected. Exiting."
    Write-Output "No Edge installations found. Script exiting."
    exit 0
}

$removedSomething = $false
$stubPath = $null

if ($chromiumInstalled) {
    Write-Output "Chromium Edge detected. Finding ie_to_edge_stub.exe before removal."

    $stubLocations = @("$env:ProgramData\ie_to_edge_stub.exe", "$env:Public\ie_to_edge_stub.exe")
    foreach ($loc in $stubLocations) {
        if (Test-Path $loc) {
            $stubPath = $loc
            Write-Output "Found stub at: $loc"
            break
        }
    }

    if (!$stubPath) {
        $stubSearch = Get-ChildItem "${env:ProgramFiles(x86)}\Microsoft\Edge" -Filter "ie_to_edge_stub.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
        if ($stubSearch) {
            $stubPath = $stubSearch.FullName
            Write-Output "Found stub at: $stubPath"
        } else {
            Write-Output "ie_to_edge_stub.exe not found in any location"
        }
    }

    if ($stubPath) {
        $scriptsDir = "C:\MyMaintenance\Scripts\OpenWebSearch"
        New-Item -ItemType Directory -Path $scriptsDir -Force -ErrorAction SilentlyContinue | Out-Null
        Copy-Item $stubPath "$scriptsDir\ie_to_edge_stub.exe" -Force -ErrorAction SilentlyContinue
        Write-Output "Copied ie_to_edge_stub.exe to $scriptsDir before Edge removal"
    }
}

if ($legacyInstalled) {
    Write-Output "Legacy Edge detected. Proceeding with removal."
    Stop-EdgeProcesses
    Remove-LegacyEdge
    $removedSomething = $true
}

if ($chromiumInstalled) {
    Write-Output "Chromium Edge detected. Proceeding with removal."
    Stop-EdgeProcesses
    Remove-ChromiumEdge
    $removedSomething = $true
}

# Only do cleanup if we removed something
if ($removedSomething) {
    # Cleanup: Remove folders containing Edge (Edge, EdgeCore, EdgeUpdate) or Temp but exclude EdgeWebView
    Write-Output "Starting cleanup of Microsoft Edge folders"
    $edgeFolders = Get-ChildItem -Path "$env:SystemDrive\Program Files (x86)\Microsoft" -Directory -ErrorAction SilentlyContinue |
    Where-Object { ($_.Name -like "*Edge*" -or $_.Name -like "*Temp*") -and $_.Name -notlike "*EdgeWebView*" }
    if ($edgeFolders) {
        Write-Output "Found $($edgeFolders.Count) Edge-related folder(s) to remove"
        $edgeFolders | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        Write-Output "Cleanup of Microsoft Edge folders completed"
    } else {
        Write-Output "No Edge-related folders found to clean up"
    }

    Remove-EdgeShortcuts
    Install-EdgeProtocolRedirect
}

# Always check for and delete Edge scheduled tasks
Write-Output "Checking for Edge scheduled tasks"
try {
    $edgeTasks = Get-ScheduledTask -TaskName "*Edge*" -ErrorAction SilentlyContinue
    if ($edgeTasks) {
        foreach ($task in $edgeTasks) {
            # Skip the EdgeRemoval task
            if ($task.TaskName -eq "EdgeRemoval") {
                Write-Output "Skipping EdgeRemoval task: $($task.TaskName)"
                continue
            }
            
            Write-Output "Found Edge scheduled task: $($task.TaskName) - State: $($task.State)"
            try {
                Unregister-ScheduledTask -TaskName $task.TaskName -TaskPath $task.TaskPath -Confirm:$false -ErrorAction SilentlyContinue
                Write-Output "Deleted scheduled task: $($task.TaskName)"
            }
            catch {
                Write-Output "Failed to delete scheduled task: $($task.TaskName) - $($_.Exception.Message)"
            }
        }
    } else {
        Write-Output "No Edge scheduled tasks found"
    }
}
catch {
    Write-Output "Failed to check scheduled tasks: $($_.Exception.Message)"
}

Write-Output "Create the EdgeUpdate key and block automatic Chromium Edge installation"
$RegPath = "HKLM:\SOFTWARE\Microsoft\EdgeUpdate"
if (!(Test-Path $RegPath)) { New-Item -Path $RegPath -Force }
New-ItemProperty -Path $RegPath -Name "DoNotUpdateToEdgeWithChromium" -Value 1 -PropertyType DWORD -Force

Write-Output "Prevent Edge installation via standard Update policies"
$PolicyPath = "HKLM:\SOFTWARE\Policies\Microsoft\EdgeUpdate"
if (!(Test-Path $PolicyPath)) { New-Item -Path $PolicyPath -Force }
New-ItemProperty -Path $PolicyPath -Name "InstallDefault" -Value 0 -PropertyType DWORD -Force
New-ItemProperty -Path $PolicyPath -Name "Install{56EB18F8-8008-4CBD-B6D0-588447950844}" -Value 0 -PropertyType DWORD -Force

Write-Output "Put Package Family Names (PFN) for both Chromium and Legacy Edge in provisioned list"
$EdgePFNs = @(
    "Microsoft.MicrosoftEdge.Stable_8wekyb3d8bbwe", # Modern Chromium Edge
    "Microsoft.MicrosoftEdge_8wekyb3d8bbwe"         # Legacy Edge
)

foreach ($PFN in $EdgePFNs) {
    $Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore\Deprovisioned\$PFN"
    if (!(Test-Path $Path)) {
        New-Item -Path $Path -Force | Out-Null
        Write-Output "Deprovisioned marker added for: $PFN"
    }
}

Write-Output "Done."
]]>
		</File>
        <File path="C:\Windows\Setup\Scripts\PauseWindowsUpdate.ps1">
<![CDATA[
& {
    $formatter = {
        $args[0].ToString( "yyyy'-'MM'-'dd'T'HH':'mm':'ssK" );
    };
    $now = [datetime]::UtcNow;
    $start = & $formatter $now;
    $end = & $formatter $now.AddDays( 7.1 );

    $params = @{
        LiteralPath = 'Registry::HKLM\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings';
        Type = 'String';
        Force = $true;
    };

    Set-ItemProperty @params -Name 'PauseFeatureUpdatesStartTime' -Value $start;
    Set-ItemProperty @params -Name 'PauseFeatureUpdatesEndTime' -Value $end;
    Set-ItemProperty @params -Name 'PauseQualityUpdatesStartTime' -Value $start;
    Set-ItemProperty @params -Name 'PauseQualityUpdatesEndTime' -Value $end;
    Set-ItemProperty @params -Name 'PauseUpdatesStartTime' -Value $start;
    Set-ItemProperty @params -Name 'PauseUpdatesExpiryTime' -Value $end;
} *>&1 | Out-String -Width 1KB -Stream >> "C:\MySetup\Logs\PauseWindowsUpdate.log";
]]>
		</File>
		<File path="C:\Windows\Setup\Scripts\PauseWindowsUpdate.xml">
<![CDATA[
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <CalendarTrigger>
      <StartBoundary>2026-01-01T12:00:00-08:00</StartBoundary>
      <Enabled>true</Enabled>
      <ScheduleByDay>
        <DaysInterval>1</DaysInterval>
      </ScheduleByDay>
    </CalendarTrigger>
    <BootTrigger>
      <Enabled>true</Enabled>
    </BootTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <Enabled>true</Enabled>
    <Hidden>false</Hidden>
    <RunOnlyIfIdle>false</RunOnlyIfIdle>
    <WakeToRun>true</WakeToRun>
    <ExecutionTimeLimit>PT5M</ExecutionTimeLimit>
    <Priority>7</Priority>
    <RestartOnFailure>
      <Interval>PT5M</Interval>
      <Count>5</Count>
    </RestartOnFailure>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</Command>
      <Arguments>-ExecutionPolicy "Unrestricted" -NoProfile -File "C:\MySetup\Scripts\PauseWindowsUpdate.ps1"</Arguments>
    </Exec>
  </Actions>
</Task>
]]>
		</File>
        <File path="C:\Windows\Setup\Scripts\MoveActiveHours.vbs">
<![CDATA[
HKLM = &H80000002
key = "SOFTWARE\Microsoft\WindowsUpdate\UX\Settings"
Set reg = GetObject("winmgmts://./root/default:StdRegProv")
current = Hour(Now)
reg.SetDWORDValue HKLM, key, "ActiveHoursStart", ( current + 23 ) Mod 24
reg.SetDWORDValue HKLM, key, "ActiveHoursEnd", ( current + 11 ) Mod 24
reg.SetDWORDValue HKLM, key, "SmartActiveHoursState", 2
]]>
		</File>
		<File path="C:\Windows\Setup\Scripts\MoveActiveHoursPrimary.xml">
<![CDATA[
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <BootTrigger>
      <Enabled>true</Enabled>
    </BootTrigger>
    <CalendarTrigger>
      <StartBoundary>2026-01-01T00:00:00</StartBoundary>
      <Enabled>true</Enabled>
      <ScheduleByDay>
        <DaysInterval>1</DaysInterval>
      </ScheduleByDay>
      <Repetition>
        <Interval>PT4H</Interval>
        <StopAtDurationEnd>false</StopAtDurationEnd>
      </Repetition>
    </CalendarTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <Enabled>true</Enabled>
    <Hidden>false</Hidden>
    <RunOnlyIfIdle>false</RunOnlyIfIdle>
    <WakeToRun>false</WakeToRun>
    <ExecutionTimeLimit>PT5M</ExecutionTimeLimit>
    <Priority>7</Priority>
    <RestartOnFailure>
      <Interval>PT5M</Interval>
      <Count>5</Count>
    </RestartOnFailure>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>C:\Windows\System32\wscript.exe</Command>
      <Arguments>"C:\MySetup\Scripts\MoveActiveHours.vbs" >> "C:\MySetup\Logs\MoveActiveHours.log" 2>&1</Arguments>
    </Exec>
  </Actions>
</Task>
]]>
		</File>
        <File path="C:\Windows\Setup\Scripts\MoveActiveHoursBackup.xml">
<![CDATA[
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <BootTrigger>
      <Enabled>true</Enabled>
    </BootTrigger>
    <CalendarTrigger>
      <StartBoundary>2026-01-01T00:05:00</StartBoundary>
      <Enabled>true</Enabled>
      <ScheduleByDay>
        <DaysInterval>1</DaysInterval>
      </ScheduleByDay>
      <Repetition>
        <Interval>PT8H</Interval>
        <StopAtDurationEnd>false</StopAtDurationEnd>
      </Repetition>
    </CalendarTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <Enabled>true</Enabled>
    <Hidden>false</Hidden>
    <RunOnlyIfIdle>false</RunOnlyIfIdle>
    <WakeToRun>true</WakeToRun>
    <ExecutionTimeLimit>PT5M</ExecutionTimeLimit>
    <Priority>7</Priority>
    <RestartOnFailure>
      <Interval>PT5M</Interval>
      <Count>5</Count>
    </RestartOnFailure>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>C:\Windows\System32\wscript.exe</Command>
      <Arguments>"C:\MySetup\Scripts\MoveActiveHours.vbs" >> "C:\MySetup\Logs\MoveActiveHours.log" 2>&1</Arguments>
    </Exec>
  </Actions>
</Task>
]]>
		</File>
    </Extensions>
</unattend>