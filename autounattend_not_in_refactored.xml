<?xml version="1.0" encoding="utf-8"?>
<unattend xmlns="urn:schemas-microsoft-com:unattend" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State">
	<!--https://schneegans.de/windows/unattend-generator/?LanguageMode=Interactive&ProcessorArchitecture=amd64&BypassRequirementsCheck=true&BypassNetworkCheck=true&KeepSensitiveFiles=true&ComputerNameMode=Random&CompactOsMode=Never&TimeZoneMode=Implicit&PartitionMode=Interactive&DiskAssertionMode=Skip&WindowsEditionMode=Interactive&InstallFromMode=Automatic&PEMode=Default&UserAccountMode=InteractiveLocal&PasswordExpirationMode=Unlimited&LockoutMode=Default&HideFiles=None&ShowFileExtensions=true&ClassicContextMenu=true&LaunchToThisPC=true&ShowEndTask=true&TaskbarSearch=Hide&TaskbarIconsMode=Default&DisableWidgets=true&LeftTaskbar=true&HideTaskViewButton=true&DisableBingResults=true&StartTilesMode=Empty&StartPinsMode=Empty&DisableWindowsUpdate=true&DisableSac=true&DisableFastStartup=true&DisableSystemRestore=true&EnableLongPaths=true&AllowPowerShellScripts=true&DisableLastAccess=true&PreventAutomaticReboot=true&TurnOffSystemSounds=true&DisableAppSuggestions=true&PreventDeviceEncryption=true&HideEdgeFre=true&DisableEdgeStartupBoost=true&DisablePointerPrecision=true&DisableAutomaticRestartSignOn=true&EffectsMode=Custom&ThumbnailsOrIcon=true&DragFullWindows=true&FontSmoothing=true&DeleteEdgeDesktopIcon=true&DesktopIconsMode=Default&StartFoldersMode=Default&WifiMode=Skip&ExpressSettings=DisableAll&LockKeysMode=Skip&StickyKeysMode=Default&ColorMode=Default&WallpaperMode=Default&LockScreenMode=Default&Remove3DViewer=true&RemoveBingSearch=true&RemoveClipchamp=true&RemoveCopilot=true&RemoveCortana=true&RemoveDevHome=true&RemoveWindowsHello=true&RemoveFamily=true&RemoveFeedbackHub=true&RemoveGameAssist=true&RemoveGetHelp=true&RemoveHandwriting=true&RemoveMailCalendar=true&RemoveMaps=true&RemoveMathInputPanel=true&RemoveMixedReality=true&RemoveZuneVideo=true&RemoveNews=true&RemoveOffice365=true&RemoveOneDrive=true&RemoveOneNote=true&RemoveOneSync=true&RemoveOutlook=true&RemovePaint3D=true&RemovePeople=true&RemovePowerAutomate=true&RemovePowerShellISE=true&RemoveQuickAssist=true&RemoveRecall=true&RemoveRdpClient=true&RemoveSkype=true&RemoveSolitaire=true&RemoveSpeech=true&RemoveStepsRecorder=true&RemoveStickyNotes=true&RemoveTeams=true&RemoveGetStarted=true&RemoveToDo=true&RemoveWallet=true&RemoveWeather=true&RemoveFaxAndScan=true&RemoveWindowsMediaPlayer=true&RemoveWordPad=true&RemoveXboxApps=true&RemoveYourPhone=true&SystemScript0=%3C%21%5BCDATA%5B%3C%23%0D%0A%23+These+script+will+run+in+the+system+context%2C+before+user+accounts+are+created.%0D%0A%5D%5D%3E&SystemScriptType0=Ps1&DefaultUserScript0=%3C%21%5BCDATA%5B%3C%23%0D%0A%23+Use+this+script+to+modify+the+default+user%27s+registry+hive.+For+example%3A%0D%0A%23+Registry%3A%3AHKU%5CDefaultUser%5C...%0D%0A%5D%5D%3E&DefaultUserScriptType0=Ps1&FirstLogonScript0=%3C%21%5BCDATA%5B%3C%23%0D%0A%23+These+script+will+run+when+the+firt+user+logs+on+after+Windows+has+been+installed.%0D%0A%23+The+first+user+to+log+on+is+typically+an+administrator.%0D%0A%5D%5D%3E&FirstLogonScriptType0=Ps1&UserOnceScript0=%3C%21%5BCDATA%5B%3C%23%0D%0A%23+These+script+will+run+whenever+a+user+logs+on+for+the+first+time.%0D%0A%5D%5D%3E&UserOnceScriptType0=Ps1&WdacMode=Skip&AppLockerMode=Skip-->
	<settings pass="offlineServicing"></settings>
	<settings pass="windowsPE">
		<component name="Microsoft-Windows-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<ImageInstall>
				<OSImage>
					<Compact>false</Compact>
				</OSImage>
			</ImageInstall>
			<UserData>
				<ProductKey>
					<Key>00000-00000-00000-00000-00000</Key>
					<WillShowUI>Always</WillShowUI>
				</ProductKey>
				<AcceptEula>true</AcceptEula>
			</UserData>
			<UseConfigurationSet>false</UseConfigurationSet>
			<RunSynchronous>
				<RunSynchronousCommand wcm:action="add">
					<Order>1</Order>
					<Path>reg.exe add "HKLM\SYSTEM\Setup\LabConfig" /v BypassTPMCheck /t REG_DWORD /d 1 /f</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>2</Order>
					<Path>reg.exe add "HKLM\SYSTEM\Setup\LabConfig" /v BypassSecureBootCheck /t REG_DWORD /d 1 /f</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>3</Order>
					<Path>reg.exe add "HKLM\SYSTEM\Setup\LabConfig" /v BypassRAMCheck /t REG_DWORD /d 1 /f</Path>
				</RunSynchronousCommand>
			</RunSynchronous>
		</component>
	</settings>
	<settings pass="generalize"></settings>
	<settings pass="specialize">
		<component name="Microsoft-Windows-Deployment" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<RunSynchronous>
				<RunSynchronousCommand wcm:action="add">
					<Order>1</Order>
					<Path>powershell.exe -WindowStyle "Normal" -NoProfile -Command "$xml = [xml]::new(); $xml.Load('C:\Windows\Panther\unattend.xml'); $sb = [scriptblock]::Create( $xml.unattend.Extensions.ExtractScript ); Invoke-Command -ScriptBlock $sb -ArgumentList $xml;"</Path>
				</RunSynchronousCommand>
                <RunSynchronousCommand wcm:action="add">
					<Order>2</Order>
					<Path>powershell.exe -WindowStyle "Normal" -ExecutionPolicy "Unrestricted" -NoProfile -File "C:\Windows\Setup\Scripts\ToMaintenance.ps1"</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>3</Order>
					<Path>powershell.exe -WindowStyle "Normal" -ExecutionPolicy "Unrestricted" -NoProfile -File "C:\MyMaintenance\Scripts\Specialize.ps1"</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>4</Order>
					<Path>reg.exe load "HKU\DefaultUser" "C:\Users\Default\NTUSER.DAT"</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>5</Order>
					<Path>powershell.exe -WindowStyle "Normal" -ExecutionPolicy "Unrestricted" -NoProfile -File "C:\MyMaintenance\Scripts\DefaultUser.ps1"</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>6</Order>
					<Path>reg.exe unload "HKU\DefaultUser"</Path>
				</RunSynchronousCommand>
			</RunSynchronous>
		</component>
	</settings>
	<settings pass="auditSystem"></settings>
	<settings pass="auditUser"></settings>
	<settings pass="oobeSystem">
		<component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<OOBE>
				<ProtectYourPC>3</ProtectYourPC>
				<HideEULAPage>true</HideEULAPage>
				<HideWirelessSetupInOOBE>true</HideWirelessSetupInOOBE>
				<HideOnlineAccountScreens>true</HideOnlineAccountScreens>
			</OOBE>
			<FirstLogonCommands>
				<SynchronousCommand wcm:action="add">
					<Order>1</Order>
					<CommandLine>powershell.exe -WindowStyle "Normal" -ExecutionPolicy "Unrestricted" -NoProfile -File "C:\MyMaintenance\Scripts\FirstLogon.ps1"</CommandLine>
				</SynchronousCommand>
			</FirstLogonCommands>
		</component>
	</settings>
	<Extensions xmlns="https://schneegans.de/windows/unattend-generator/">
		<ExtractScript>
param(
    [xml] $Document
);

foreach( $file in $Document.unattend.Extensions.File ) {
    $path = [System.Environment]::ExpandEnvironmentVariables( $file.GetAttribute( 'path' ) );
    mkdir -Path( $path | Split-Path -Parent ) -ErrorAction 'SilentlyContinue';
    $encoding = switch( [System.IO.Path]::GetExtension( $path ) ) {
        { $_ -in '.ps1', '.xml' } { [System.Text.Encoding]::UTF8; }
        { $_ -in '.reg', '.vbs', '.js' } { [System.Text.UnicodeEncoding]::new( $false, $true ); }
        default { [System.Text.Encoding]::Default; }
    };
    $bytes = $encoding.GetPreamble() + $encoding.GetBytes( $file.InnerText.Trim() );
    [System.IO.File]::WriteAllBytes( $path, $bytes );
}
		</ExtractScript>
        <File path="C:\Windows\Setup\Scripts\ToMaintenance.ps1">
<![CDATA[
# ============================================================
# SetupMaintenance.ps1
# Runs during SPECIALIZE pass
# Creates persistent maintenance folder structure and
# copies original Setup scripts for post-upgrade reuse.
# ============================================================

$MaintenanceRoot = "C:\MyMaintenance"
$Scripts = Join-Path $MaintenanceRoot "Scripts"
$LogDir          = Join-Path $MaintenanceRoot "Logs"
$StateDir        = Join-Path $MaintenanceRoot "State"

# --- Create folder structure ---
$folders = @(
    $Scripts,
    $LogDir,
    $StateDir
)

foreach ($folder in $folders) {
    if (-not (Test-Path $folder)) {
        New-Item -Path $folder -ItemType Directory -Force | Out-Null
    }
}

# --- Copy original Setup scripts ---
$Source = "C:\Windows\Setup\Scripts"

if (Test-Path $Source) {
    Copy-Item -Path "$Source\*" -Destination $Scripts -Recurse -Force -ErrorAction SilentlyContinue
} else {
    # Optional: log a warning if needed
}

# --- Store current OS build number ---
$Build = (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").CurrentBuildNumber
$Build | Out-File -FilePath (Join-Path $StateDir "LastBuild.txt") -Encoding ASCII -Force
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\PostFeatureUpdate.ps1">
<![CDATA[
$Scripts = "C:\MyMaintenance\Scripts"
$LogDir  = "C:\MyMaintenance\Logs"
$LogFile = Join-Path $LogDir "PostFeatureUpdate.log"

# --- Ensure log directory exists ---
if (-not (Test-Path $LogDir)) {
    New-Item -Path $LogDir -ItemType Directory -Force | Out-Null
}

function Write-Log {
    param([string]$Message)
    $timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    "$timestamp  $Message" | Out-File -FilePath $LogFile -Append -Encoding UTF8
}

Write-Log "=== Maintenance run started ==="

# --- Ensure working directory is correct ---
try {
    Set-Location $Scripts
    Write-Log "Working directory set to $Scripts"
}
catch {
    Write-Log "ERROR: Failed to set working directory. $_"
}

# --- Helper to run scripts with logging ---
function Run-Script {
    param([string]$ScriptPath)

    if (-not (Test-Path $ScriptPath)) {
        Write-Log "ERROR: Script not found: $ScriptPath"
        return
    }

    Write-Log "Running script: $ScriptPath"

    try {
        & $ScriptPath
        Write-Log "Completed: $ScriptPath"
    }
    catch {
        Write-Log "ERROR in $ScriptPath : $_"
    }
}

# --- Run Specialize.ps1 ---
Run-Script "$Scripts\Specialize.ps1"

# --- Modify Default User profile ---
Write-Log "Loading Default User registry hive..."

$HiveLoaded = $false
try {
    $result = reg.exe load "HKU\DefaultUser" "C:\Users\Default\NTUSER.DAT"
    if ($LASTEXITCODE -eq 0) {
        $HiveLoaded = $true
        Write-Log "Default User hive loaded successfully."
    }
    else {
        Write-Log "ERROR: Failed to load Default User hive. Exit code: $LASTEXITCODE"
    }
}
catch {
    Write-Log "ERROR: Exception while loading Default User hive. $_"
}

if ($HiveLoaded) {
    Run-Script "$Scripts\DefaultUser.ps1"

    Write-Log "Unloading Default User hive..."
    try {
        reg.exe unload "HKU\DefaultUser" | Out-Null
        Write-Log "Default User hive unloaded."
    }
    catch {
        Write-Log "ERROR: Failed to unload Default User hive. $_"
    }
}

# --- Run FirstLogon.ps1 ---
Run-Script "$Scripts\FirstLogon.ps1"

Write-Log "=== Maintenance run finished ==="
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\RunMaintenance.ps1">
<![CDATA[
# ============================================================
# RunMaintenance.ps1
# Runs at every boot via Scheduled Task (SYSTEM)
# Detects OS build changes and re-runs maintenance scripts.
# ============================================================

$MaintenanceRoot = "C:\MyMaintenance"
$Scripts         = Join-Path $MaintenanceRoot "Scripts"
$LogDir          = Join-Path $MaintenanceRoot "Logs"
$StateDir        = Join-Path $MaintenanceRoot "State"
$BuildFile       = Join-Path $StateDir "LastBuild.txt"
$LogFile         = Join-Path $LogDir "RunMaintenance.log"

# --- Ensure logging directory exists ---
if (-not (Test-Path $LogDir)) {
    New-Item -Path $LogDir -ItemType Directory -Force | Out-Null
}

function Write-Log {
    param([string]$Message)
    $timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    "$timestamp  $Message" | Out-File -FilePath $LogFile -Append -Encoding UTF8
}

Write-Log "=== Maintenance task started ==="

# --- Get current OS build ---
try {
    $CurrentBuild = (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").CurrentBuildNumber
    Write-Log "Current OS Build: $CurrentBuild"
}
catch {
    Write-Log "ERROR: Unable to read current OS build. $_"
    exit 1
}

# --- Read stored build ---
if (Test-Path $BuildFile) {
    $StoredBuild = Get-Content $BuildFile -ErrorAction SilentlyContinue
    Write-Log "Stored OS Build: $StoredBuild"
}
else {
    Write-Log "No stored build found. Creating baseline and exiting."
    $CurrentBuild | Out-File -FilePath $BuildFile -Encoding ASCII -Force
    exit 0
}

# --- Compare builds ---
if ($StoredBuild -eq $CurrentBuild) {
    Write-Log "Build unchanged. No maintenance required."
    Write-Log "=== Maintenance task finished ==="
    exit 0
}

Write-Log "Build changed! Running maintenance scripts..."

# --- Run your main orchestrator script ---
$MainScript = Join-Path $Scripts "PostFeatureUpdate.ps1"

if (Test-Path $MainScript) {
    try {
        Write-Log "Executing $MainScript"
        Set-Location $Scripts
        powershell.exe -ExecutionPolicy Bypass -File $MainScript
        Write-Log "Maintenance scripts completed successfully."
    }
    catch {
        Write-Log "ERROR running maintenance scripts: $_"
    }
}
else {
    Write-Log "ERROR: Main script not found: $MainScript"
}

# --- Update stored build number ---
try {
    $CurrentBuild | Out-File -FilePath $BuildFile -Encoding ASCII -Force
    Write-Log "Updated stored build number to $CurrentBuild"
}
catch {
    Write-Log "ERROR updating stored build number: $_"
}

Write-Log "=== Maintenance task finished ==="
exit 0
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\RunMaintenance.xml">
<![CDATA[
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <BootTrigger>
      <Enabled>true</Enabled>
      <Delay>PT30S</Delay>
    </BootTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <IdleSettings>
      <StopOnIdleEnd>false</StopOnIdleEnd>
      <RestartOnIdle>false</RestartOnIdle>
    </IdleSettings>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <Enabled>true</Enabled>
    <Hidden>false</Hidden>
    <RunOnlyIfIdle>false</RunOnlyIfIdle>
    <WakeToRun>false</WakeToRun>
    <ExecutionTimeLimit>PT0S</ExecutionTimeLimit>
    <Priority>5</Priority>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>powershell.exe</Command>
      <Arguments>-NoProfile -ExecutionPolicy Bypass -File "C:\MyMaintenance\Scripts\RunMaintenance.ps1"</Arguments>
    </Exec>
  </Actions>
</Task>
]]>
        </File>
		<File path="C:\Windows\Setup\Scripts\Specialize.ps1">
<![CDATA[
$scripts = @(
    {
        & 'C:\MyMaintenance\Scripts\RestartNagTaskSetup.ps1';
    };
    {
		Register-ScheduledTask -TaskName 'RunMaintenance' -Xml $( Get-Content -LiteralPath 'C:\MyMaintenance\Scripts\RunMaintenance.xml' -Raw );
	};
);

& {
  [float] $complete = 0;
  [float] $increment = 100 / $scripts.Count;
  foreach( $script in $scripts ) {
    Write-Progress -Activity 'Running scripts to customize your Windows installation. Do not close this window.' -PercentComplete $complete;
    "*** Will now execute command $([char]0xAB){0}$([char]0xBB)." -f $(
      $str = $script.ToString().Trim() -replace '\s+', ' ';
      $max = 100;
      if( $str.Length -le $max ) {
        $str;
      } else {
        $str.Substring( 0, $max - 1 ) + "$([char]0x2026)";
      }
    );
    $start = [datetime]::Now;
    & $script;
    '*** Finished executing command after {0:0} ms.' -f [datetime]::Now.Subtract( $start ).TotalMilliseconds;
    "`r`n" * 3;
    $complete += $increment;
  }
} *>&1 | Out-String -Width 1KB -Stream >> "C:\MyMaintenance\Logs\Specialize.log";
]]>
		</File>
		<File path="C:\Windows\Setup\Scripts\UserOnce.ps1">
<![CDATA[
$scripts = @(
	#{
    #    $tag = "$env:LOCALAPPDATA\RestartNag_Done.tag"
    #    if (-not (Test-Path $tag)) {
    #        New-Item -Path $tag -ItemType "File" -Force;
    #    }
    #    $rebootPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired"
    #    if (-not (Test-Path $rebootPath)) {
    #        New-Item -Path $rebootPath -Force | Out-Null
    #    }
    #    Start-ScheduledTask -TaskName "RestartNag";
	#};
);

& {
  [float] $complete = 0;
  [float] $increment = 100 / $scripts.Count;
  foreach( $script in $scripts ) {
    Write-Progress -Activity 'Running scripts to configure this user account. Do not close this window.' -PercentComplete $complete;
    "*** Will now execute command $([char]0xAB){0}$([char]0xBB)." -f $(
      $str = $script.ToString().Trim() -replace '\s+', ' ';
      $max = 100;
      if( $str.Length -le $max ) {
        $str;
      } else {
        $str.Substring( 0, $max - 1 ) + "$([char]0x2026)";
      }
    );
    $start = [datetime]::Now;
    & $script;
    '*** Finished executing command after {0:0} ms.' -f [datetime]::Now.Subtract( $start ).TotalMilliseconds;
    "`r`n" * 3;
    $complete += $increment;
  }
} *>&1 | Out-String -Width 1KB -Stream >> "$env:TEMP\UserOnce.log";
]]>
		</File>
        
        <File path="C:\Windows\Setup\Scripts\RestartNag.ps1">
<![CDATA[
$tagPath = "$env:LOCALAPPDATA\RestartNag_Done.tag"
$timeout = New-TimeSpan -Minutes 15 # Maximum time to wait
$timer = [System.Diagnostics.Stopwatch]::StartNew()

while (!(Test-Path $tagPath)) {
    if ($timer.Elapsed -gt $timeout) { break } # Stop waiting after 15 mins
    Start-Sleep -Seconds 10
}

# STOP NAGGING IF REBOOT IS COMPLETE
# Checks common registry keys that indicate a pending update reboot
$rebootPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired"
$pendingFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name PendingFileRenameOperations -ErrorAction SilentlyContinue

if (-not (Test-Path $rebootPath) -and ($null -eq $pendingFile)) {
    exit # No reboot pending, exit silently
}

# PREVENT DUPLICATE WINDOWS
# If the window is already open, don't open another one
if (Get-Process -Name "powershell" | Where-Object { $_.MainWindowTitle -eq "Restart Required" }) { 
    exit 
}

# LOAD TYPES & ENABLE STYLES
Add-Type -AssemblyName System.Windows.Forms, System.Drawing
[System.Windows.Forms.Application]::EnableVisualStyles()

# THEME DETECTION (Windows 10 Taskbar match)
$bgColor = [System.Drawing.Color]::FromArgb(45, 45, 48) # Dark Taskbar Gray
$titleColor = [System.Drawing.Color]::White
$descColor = [System.Drawing.Color]::FromArgb(180, 180, 180)

# Check for Light Mode
$themePath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes\Personalize"
$isLightTheme = Get-ItemPropertyValue -Path $themePath -Name "AppsUseLightTheme" -ErrorAction SilentlyContinue
if ($isLightTheme -eq 1) {
    $bgColor = [System.Drawing.Color]::FromArgb(240, 240, 240)
    $titleColor = [System.Drawing.Color]::Black
    $descColor = [System.Drawing.Color]::FromArgb(100, 100, 100)
}

# CREATE FORM
$form = New-Object System.Windows.Forms.Form
$form.Text = "Restart Required"
$form.Size = New-Object System.Drawing.Size(360, 100)
$form.FormBorderStyle = "None"
$form.BackColor = $bgColor
$form.TopMost = $true
$form.Opacity = 0.95
$form.ShowInTaskbar = $false

# Position (Bottom-Right)
$workingArea = [System.Windows.Forms.Screen]::PrimaryScreen.WorkingArea
$form.Location = New-Object System.Drawing.Point(($workingArea.Width - 370), ($workingArea.Height - 115))
$form.StartPosition = "Manual"

# UI Elements (Title)
$title = New-Object System.Windows.Forms.Label
$title.Text = "Restart Required"
$title.ForeColor = $titleColor
$title.Font = New-Object System.Drawing.Font("Segoe UI Semibold", 10.5)
$title.AutoSize = $true
$title.Location = New-Object System.Drawing.Point(15, 15)
$form.Controls.Add($title)

# UI Elements (Description)
$desc = New-Object System.Windows.Forms.Label
$desc.Text = "Please restart your computer to complete Windows installation customizations and maintenance."
$desc.ForeColor = $descColor
$desc.Font = New-Object System.Drawing.Font("Segoe UI", 9)
$desc.Size = New-Object System.Drawing.Size(300, 40)
$desc.Location = New-Object System.Drawing.Point(15, 40)
$form.Controls.Add($desc)

# Close Button
$closeBtn = New-Object System.Windows.Forms.Button
$closeBtn.Text = "X"
$closeBtn.Size = New-Object System.Drawing.Size(25, 25)
$closeBtn.Location = New-Object System.Drawing.Point(325, 12)
$closeBtn.FlatStyle = "Flat"
$closeBtn.FlatAppearance.BorderSize = 0
$closeBtn.ForeColor = $titleColor
$closeBtn.Add_Click({ $form.Close() })
$form.Controls.Add($closeBtn)

$timer = New-Object System.Windows.Forms.Timer
$timer.Interval = 30000   # 30 seconds
$timer.Add_Tick({
    $timer.Stop()
    $form.Close()
})
$timer.Start()

# SHOW DIALOG
$form.ShowDialog() | Out-Null
]]>
        </File>
        <File path="C:\Windows\Setup\Scripts\RestartNagTaskSetup.ps1">
<![CDATA[
$ScriptPath = "C:\MyMaintenance\Scripts\RestartNag.ps1"

# Point to conhost.exe as the primary executable
$ConhostPath = "powershell.exe"

# The command to run as an argument for conhost
$PSArguments = "-NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -Sta -File `"$ScriptPath`""

# Use --headless to ensure NO window is allocated
$Action = New-ScheduledTaskAction -Execute $ConhostPath `
    -Argument "--headless $PSArguments"

# Triggers: At Logon + Hourly Repetition
# Trigger A: Fires as soon as any user logs in
$AtLogon = New-ScheduledTaskTrigger -AtLogOn

# Trigger B: Fires every hour (starting now) to handle the 'nagging'
$Repetition = New-ScheduledTaskTrigger -Once -At (Get-Date) -RepetitionInterval (New-TimeSpan -Hours 1)

$Triggers = @($AtLogon, $Repetition)

# Principal: Run as the 'Users' Group (S-1-5-32-545)
# This is key for the dialog to appear in the user's interactive session.
$Principal = New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545"

# Settings
$Settings = New-ScheduledTaskSettingsSet -StartWhenAvailable -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries

# Register
Register-ScheduledTask -TaskName "RestartNag" -Action $Action -Trigger $Triggers -Principal $Principal -Settings $Settings -Force
]]>
        </File>
	</Extensions>
</unattend>